<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Barrelfish: include/barrelfish/lmp_endpoints.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Barrelfish
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_d4e97a57a2af26ed01adfb3ccd13c638.html">barrelfish</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">lmp_endpoints.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>LMP endpoints declarations.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlmp__endpoint.html">lmp_endpoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">LMP endpoint structure (including data accessed only by user code)  <a href="structlmp__endpoint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlmp__recv__buf.html">lmp_recv_buf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Message layout in user's buffer.  <a href="structlmp__recv__buf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlmp__recv__msg.html">lmp_recv_msg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fixed-length version of <a class="el" href="structlmp__recv__buf.html" title="Message layout in user&#39;s buffer. ">lmp_recv_buf</a>.  <a href="structlmp__recv__msg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:afa04b4c8717e5b485d0ab510c3df0464"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa04b4c8717e5b485d0ab510c3df0464"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lmp__endpoints_8h.html#afa04b4c8717e5b485d0ab510c3df0464">LMP_RECV_LENGTH</a>&#160;&#160;&#160;(<a class="el" href="x86__64_2barrelfish__kpi_2lmp__arch_8h.html#ad81a630664f43e8e6e673df699b1dbe7">LMP_MSG_LENGTH</a> + LMP_RECV_HEADER_LENGTH)</td></tr>
<tr class="memdesc:afa04b4c8717e5b485d0ab510c3df0464"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-endpoint size of a maximum-sized LMP message plus header. <br /></td></tr>
<tr class="separator:afa04b4c8717e5b485d0ab510c3df0464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac03188a2eccfe1538ae93b16a2347e4d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac03188a2eccfe1538ae93b16a2347e4d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lmp__endpoints_8h.html#ac03188a2eccfe1538ae93b16a2347e4d">DEFAULT_LMP_BUF_WORDS</a>&#160;&#160;&#160;(<a class="el" href="lmp__endpoints_8h.html#afa04b4c8717e5b485d0ab510c3df0464">LMP_RECV_LENGTH</a> * 2)</td></tr>
<tr class="memdesc:ac03188a2eccfe1538ae93b16a2347e4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default size of LMP endpoint buffer (in words), must be &gt;= LMP_RECV_LENGTH. <br /></td></tr>
<tr class="separator:ac03188a2eccfe1538ae93b16a2347e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b11bfb524912973c2b8fe16b86fedb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab8b11bfb524912973c2b8fe16b86fedb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lmp__endpoints_8h.html#ab8b11bfb524912973c2b8fe16b86fedb">LMP_RECV_BUF_SIZE</a>(n)&#160;&#160;&#160;(sizeof(struct <a class="el" href="structlmp__recv__buf.html">lmp_recv_buf</a>) + ((n)*sizeof(uintptr_t)))</td></tr>
<tr class="memdesc:ab8b11bfb524912973c2b8fe16b86fedb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the size needed for an <a class="el" href="structlmp__recv__buf.html" title="Message layout in user&#39;s buffer. ">lmp_recv_buf</a> buffer. <br /></td></tr>
<tr class="separator:ab8b11bfb524912973c2b8fe16b86fedb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f9a64f60a2f3b7632b93809e98f717e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7f9a64f60a2f3b7632b93809e98f717e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lmp__endpoints_8h.html#a7f9a64f60a2f3b7632b93809e98f717e">LMP_RECV_MSG_INIT</a>&#160;&#160;&#160;{ .buf.buflen = <a class="el" href="x86__64_2barrelfish__kpi_2lmp__arch_8h.html#ad81a630664f43e8e6e673df699b1dbe7">LMP_MSG_LENGTH</a> };</td></tr>
<tr class="memdesc:a7f9a64f60a2f3b7632b93809e98f717e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static initialiser for <a class="el" href="structlmp__recv__msg.html" title="Fixed-length version of lmp_recv_buf. ">lmp_recv_msg</a>. <br /></td></tr>
<tr class="separator:a7f9a64f60a2f3b7632b93809e98f717e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:acb975d5ab218b881b38517e0171ec972"><td class="memItemLeft" align="right" valign="top">errval_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lmp__endpoints_8h.html#acb975d5ab218b881b38517e0171ec972">lmp_endpoint_alloc</a> (size_t buflen, struct <a class="el" href="structlmp__endpoint.html">lmp_endpoint</a> **retep)</td></tr>
<tr class="memdesc:acb975d5ab218b881b38517e0171ec972"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate an LMP endpoint buffer on the current dispatcher.  <a href="#acb975d5ab218b881b38517e0171ec972">More...</a><br /></td></tr>
<tr class="separator:acb975d5ab218b881b38517e0171ec972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a020e81c85d177a06916f7776e406265b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lmp__endpoints_8h.html#a020e81c85d177a06916f7776e406265b">lmp_endpoint_free</a> (struct <a class="el" href="structlmp__endpoint.html">lmp_endpoint</a> *ep)</td></tr>
<tr class="memdesc:a020e81c85d177a06916f7776e406265b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free an LMP endpoint buffer on the current dispatcher.  <a href="#a020e81c85d177a06916f7776e406265b">More...</a><br /></td></tr>
<tr class="separator:a020e81c85d177a06916f7776e406265b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa01fa6f99428082565968503764492e6"><td class="memItemLeft" align="right" valign="top">errval_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lmp__endpoints_8h.html#aa01fa6f99428082565968503764492e6">lmp_endpoint_create_in_slot</a> (size_t buflen, struct <a class="el" href="structcapref.html">capref</a> dest, struct <a class="el" href="structlmp__endpoint.html">lmp_endpoint</a> **retep)</td></tr>
<tr class="memdesc:aa01fa6f99428082565968503764492e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create endpoint to caller on current dispatcher in a specified slot.  <a href="#aa01fa6f99428082565968503764492e6">More...</a><br /></td></tr>
<tr class="separator:aa01fa6f99428082565968503764492e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbbdaf5e159953c1c7472f974908b543"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lmp__endpoints_8h.html#adbbdaf5e159953c1c7472f974908b543">lmp_endpoint_set_recv_slot</a> (struct <a class="el" href="structlmp__endpoint.html">lmp_endpoint</a> *ep, struct <a class="el" href="structcapref.html">capref</a> slot)</td></tr>
<tr class="memdesc:adbbdaf5e159953c1c7472f974908b543"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the receive capability slot for a given endpoint.  <a href="#adbbdaf5e159953c1c7472f974908b543">More...</a><br /></td></tr>
<tr class="separator:adbbdaf5e159953c1c7472f974908b543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07977f075828e5082f40bf3b20ddcba6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lmp__endpoints_8h.html#a07977f075828e5082f40bf3b20ddcba6">lmp_endpoint_can_recv</a> (struct <a class="el" href="structlmp__endpoint.html">lmp_endpoint</a> *ep)</td></tr>
<tr class="memdesc:a07977f075828e5082f40bf3b20ddcba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff there are messages in the given endpoint buffer.  <a href="#a07977f075828e5082f40bf3b20ddcba6">More...</a><br /></td></tr>
<tr class="separator:a07977f075828e5082f40bf3b20ddcba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54bb313a3ff278201758ad8cc95b3c3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lmp__endpoints_8h.html#a54bb313a3ff278201758ad8cc95b3c3f">lmp_endpoints_poll_disabled</a> (dispatcher_handle_t handle)</td></tr>
<tr class="memdesc:a54bb313a3ff278201758ad8cc95b3c3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check incoming LMP endpoints for messages and notify waitsets.  <a href="#a54bb313a3ff278201758ad8cc95b3c3f">More...</a><br /></td></tr>
<tr class="separator:a54bb313a3ff278201758ad8cc95b3c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cd12a958fe7ab1a29924a9035f77b37"><td class="memItemLeft" align="right" valign="top">errval_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lmp__endpoints_8h.html#a9cd12a958fe7ab1a29924a9035f77b37">lmp_endpoint_recv</a> (struct <a class="el" href="structlmp__endpoint.html">lmp_endpoint</a> *ep, struct <a class="el" href="structlmp__recv__buf.html">lmp_recv_buf</a> *buf, struct <a class="el" href="structcapref.html">capref</a> *cap)</td></tr>
<tr class="memdesc:a9cd12a958fe7ab1a29924a9035f77b37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve an LMP message from an endpoint, if possible.  <a href="#a9cd12a958fe7ab1a29924a9035f77b37">More...</a><br /></td></tr>
<tr class="separator:a9cd12a958fe7ab1a29924a9035f77b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad59942f0ede0010811462a75a403f640"><td class="memItemLeft" align="right" valign="top">errval_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lmp__endpoints_8h.html#ad59942f0ede0010811462a75a403f640">lmp_endpoint_register</a> (struct <a class="el" href="structlmp__endpoint.html">lmp_endpoint</a> *ep, struct <a class="el" href="structwaitset.html">waitset</a> *ws, struct event_closure closure)</td></tr>
<tr class="memdesc:ad59942f0ede0010811462a75a403f640"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an event handler to be notified when messages can be received.  <a href="#ad59942f0ede0010811462a75a403f640">More...</a><br /></td></tr>
<tr class="separator:ad59942f0ede0010811462a75a403f640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea4e587e11ca46203f673b4a1b7161d"><td class="memItemLeft" align="right" valign="top">errval_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lmp__endpoints_8h.html#abea4e587e11ca46203f673b4a1b7161d">lmp_endpoint_deregister</a> (struct <a class="el" href="structlmp__endpoint.html">lmp_endpoint</a> *ep)</td></tr>
<tr class="memdesc:abea4e587e11ca46203f673b4a1b7161d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel an event registration made with <a class="el" href="lmp__endpoints_8c.html#ad59942f0ede0010811462a75a403f640" title="Register an event handler to be notified when messages can be received. ">lmp_endpoint_register()</a>  <a href="#abea4e587e11ca46203f673b4a1b7161d">More...</a><br /></td></tr>
<tr class="separator:abea4e587e11ca46203f673b4a1b7161d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad12eef7d700e5a99172a44d48bb7cd47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lmp__endpoints_8h.html#ad12eef7d700e5a99172a44d48bb7cd47">lmp_endpoint_migrate</a> (struct <a class="el" href="structlmp__endpoint.html">lmp_endpoint</a> *ep, struct <a class="el" href="structwaitset.html">waitset</a> *ws)</td></tr>
<tr class="memdesc:ad12eef7d700e5a99172a44d48bb7cd47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Migrate an event registration made with <a class="el" href="lmp__endpoints_8c.html#ad59942f0ede0010811462a75a403f640" title="Register an event handler to be notified when messages can be received. ">lmp_endpoint_register()</a> to a new waitset.  <a href="#ad12eef7d700e5a99172a44d48bb7cd47">More...</a><br /></td></tr>
<tr class="separator:ad12eef7d700e5a99172a44d48bb7cd47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef28cf2dd4ea4d2d5890f2084cdfafa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lmp__endpoints_8h.html#a4ef28cf2dd4ea4d2d5890f2084cdfafa">lmp_endpoint_store_lrpc_disabled</a> (struct <a class="el" href="structlmp__endpoint.html">lmp_endpoint</a> *ep, uint32_t bufpos, uintptr_t arg1, uintptr_t arg2, uintptr_t arg3, uintptr_t arg4)</td></tr>
<tr class="memdesc:a4ef28cf2dd4ea4d2d5890f2084cdfafa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store a newly-received LRPC message into an endpoint buffer.  <a href="#a4ef28cf2dd4ea4d2d5890f2084cdfafa">More...</a><br /></td></tr>
<tr class="separator:a4ef28cf2dd4ea4d2d5890f2084cdfafa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa5cfb0e7cb904ec0d23537202430bef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa5cfb0e7cb904ec0d23537202430bef"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lmp__endpoints_8h.html#aaa5cfb0e7cb904ec0d23537202430bef">lmp_endpoint_init</a> (void)</td></tr>
<tr class="memdesc:aaa5cfb0e7cb904ec0d23537202430bef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize LMP endpoint subsystem. <br /></td></tr>
<tr class="separator:aaa5cfb0e7cb904ec0d23537202430bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>LMP endpoints declarations. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="acb975d5ab218b881b38517e0171ec972"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">errval_t lmp_endpoint_alloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buflen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structlmp__endpoint.html">lmp_endpoint</a> **&#160;</td>
          <td class="paramname"><em>retep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate an LMP endpoint buffer on the current dispatcher. </p>
<p>In order to accomodate for the in-kernel sentinel word, the allocated size of the buffer will be one larger than buflen.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buflen</td><td>Length of incoming LMP buffer, in words </td></tr>
    <tr><td class="paramname">retep</td><td>Double pointer to LMP endpoint, filled-in with allocated EP </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a07977f075828e5082f40bf3b20ddcba6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lmp_endpoint_can_recv </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlmp__endpoint.html">lmp_endpoint</a> *&#160;</td>
          <td class="paramname"><em>ep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true iff there are messages in the given endpoint buffer. </p>
<p>May be called enabled or disabled. As a result, when enabled, the result may be incorrect as soon as the function returns. </p>

</div>
</div>
<a class="anchor" id="aa01fa6f99428082565968503764492e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">errval_t lmp_endpoint_create_in_slot </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buflen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcapref.html">capref</a>&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structlmp__endpoint.html">lmp_endpoint</a> **&#160;</td>
          <td class="paramname"><em>retep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create endpoint to caller on current dispatcher in a specified slot. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buflen</td><td>Length of incoming LMP buffer, in words </td></tr>
    <tr><td class="paramname">dest</td><td>Location of empty slot in which to create endpoint </td></tr>
    <tr><td class="paramname">retep</td><td>Double pointer to LMP endpoint, filled-in with allocated EP</td></tr>
  </table>
  </dd>
</dl>
<p>This function mints into the given slot an endpoint capability to the current dispatcher. </p>

</div>
</div>
<a class="anchor" id="abea4e587e11ca46203f673b4a1b7161d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">errval_t lmp_endpoint_deregister </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlmp__endpoint.html">lmp_endpoint</a> *&#160;</td>
          <td class="paramname"><em>ep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cancel an event registration made with <a class="el" href="lmp__endpoints_8c.html#ad59942f0ede0010811462a75a403f640" title="Register an event handler to be notified when messages can be received. ">lmp_endpoint_register()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ep</td><td>LMP Endpoint </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a020e81c85d177a06916f7776e406265b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lmp_endpoint_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlmp__endpoint.html">lmp_endpoint</a> *&#160;</td>
          <td class="paramname"><em>ep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free an LMP endpoint buffer on the current dispatcher. </p>
<p>Does not delete the endpoint capability nor free any receive slot.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ep</td><td>LMP endpoint </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad12eef7d700e5a99172a44d48bb7cd47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lmp_endpoint_migrate </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlmp__endpoint.html">lmp_endpoint</a> *&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structwaitset.html">waitset</a> *&#160;</td>
          <td class="paramname"><em>ws</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Migrate an event registration made with <a class="el" href="lmp__endpoints_8c.html#ad59942f0ede0010811462a75a403f640" title="Register an event handler to be notified when messages can be received. ">lmp_endpoint_register()</a> to a new waitset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ep</td><td>LMP Endpoint </td></tr>
    <tr><td class="paramname">ws</td><td>New waitset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9cd12a958fe7ab1a29924a9035f77b37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">errval_t lmp_endpoint_recv </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlmp__endpoint.html">lmp_endpoint</a> *&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structlmp__recv__buf.html">lmp_recv_buf</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcapref.html">capref</a> *&#160;</td>
          <td class="paramname"><em>cap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve an LMP message from an endpoint, if possible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ep</td><td>Endpoint </td></tr>
    <tr><td class="paramname">buf</td><td>LMP message buffer, to be filled-in </td></tr>
    <tr><td class="paramname">cap</td><td>If non-NULL, filled-in with location of received capability, if any</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LIB_ERR_NO_LMP_MSG if no message is available </dd>
<dd>
LIB_ERR_LMP_RECV_BUF_OVERFLOW if user-provided receive buffer is too small to store the entire message </dd></dl>

</div>
</div>
<a class="anchor" id="ad59942f0ede0010811462a75a403f640"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">errval_t lmp_endpoint_register </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlmp__endpoint.html">lmp_endpoint</a> *&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structwaitset.html">waitset</a> *&#160;</td>
          <td class="paramname"><em>ws</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct event_closure&#160;</td>
          <td class="paramname"><em>closure</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register an event handler to be notified when messages can be received. </p>
<p>In the future, call the closure on the given waitset when it is likely that a message can be received on the endpoint. An endpoint may only be registered with a single event handler on a single waitset at any one time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ep</td><td>LMP endpoint </td></tr>
    <tr><td class="paramname">ws</td><td>Waitset </td></tr>
    <tr><td class="paramname">closure</td><td>Event handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adbbdaf5e159953c1c7472f974908b543"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lmp_endpoint_set_recv_slot </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlmp__endpoint.html">lmp_endpoint</a> *&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcapref.html">capref</a>&#160;</td>
          <td class="paramname"><em>slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the receive capability slot for a given endpoint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ep</td><td>Endpoint returned from messages_lmp_alloc_endpoint() </td></tr>
    <tr><td class="paramname">slot</td><td>Receive slot </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4ef28cf2dd4ea4d2d5890f2084cdfafa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lmp_endpoint_store_lrpc_disabled </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlmp__endpoint.html">lmp_endpoint</a> *&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bufpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>arg2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>arg3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>arg4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store a newly-received LRPC message into an endpoint buffer. </p>
<p>Must be called while disabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ep</td><td>Endpoint </td></tr>
    <tr><td class="paramname">bufpos</td><td>Reserved position in endpoint message buffer </td></tr>
    <tr><td class="paramname">arg1</td><td>Message payload </td></tr>
    <tr><td class="paramname">arg2</td><td>Message payload </td></tr>
    <tr><td class="paramname">arg3</td><td>Message payload </td></tr>
    <tr><td class="paramname">arg4</td><td>Message payload </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a54bb313a3ff278201758ad8cc95b3c3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lmp_endpoints_poll_disabled </td>
          <td>(</td>
          <td class="paramtype">dispatcher_handle_t&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check incoming LMP endpoints for messages and notify waitsets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">disp_priv</td><td>Dispatcher's private data</td></tr>
  </table>
  </dd>
</dl>
<p>Must be called while disabled. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
