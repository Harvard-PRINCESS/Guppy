<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Barrelfish: lib/numa/alloc.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Barrelfish
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_0432dbf0297315a55d3bd771504e8ad0.html">numa</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">alloc.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>General Numa functions.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a16ed82504021427c568854931c11bc3b"><td class="memItemLeft" align="right" valign="top">struct bitmap *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="alloc_8c.html#a16ed82504021427c568854931c11bc3b">numa_get_interleave_mask</a> (void)</td></tr>
<tr class="memdesc:a16ed82504021427c568854931c11bc3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the current interleave mask  <a href="#a16ed82504021427c568854931c11bc3b">More...</a><br /></td></tr>
<tr class="separator:a16ed82504021427c568854931c11bc3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d9646ec73af0a36cdd00302da6aeb0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="alloc_8c.html#a4d9646ec73af0a36cdd00302da6aeb0e">numa_set_interleave_mask</a> (struct bitmap *nodemask)</td></tr>
<tr class="memdesc:a4d9646ec73af0a36cdd00302da6aeb0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the memory interleave mask for the current task to nodemask  <a href="#a4d9646ec73af0a36cdd00302da6aeb0e">More...</a><br /></td></tr>
<tr class="separator:a4d9646ec73af0a36cdd00302da6aeb0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02df68ef54915fb3dd10e4ad761fc690"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="alloc_8c.html#a02df68ef54915fb3dd10e4ad761fc690">numa_bind</a> (struct bitmap *nodemask)</td></tr>
<tr class="memdesc:a02df68ef54915fb3dd10e4ad761fc690"><td class="mdescLeft">&#160;</td><td class="mdescRight">binds the current task and its children to the nodes specified in nodemask.  <a href="#a02df68ef54915fb3dd10e4ad761fc690">More...</a><br /></td></tr>
<tr class="separator:a02df68ef54915fb3dd10e4ad761fc690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21a5645afe199400042a64e960a3f14e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21a5645afe199400042a64e960a3f14e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="alloc_8c.html#a21a5645afe199400042a64e960a3f14e">numa_set_localalloc</a> (void)</td></tr>
<tr class="memdesc:a21a5645afe199400042a64e960a3f14e"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the memory allocation policy for the calling task to local allocation. <br /></td></tr>
<tr class="separator:a21a5645afe199400042a64e960a3f14e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03781879a5c16360c1635004f5b3d0ce"><td class="memItemLeft" align="right" valign="top">errval_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="alloc_8c.html#a03781879a5c16360c1635004f5b3d0ce">numa_set_membind</a> (struct bitmap *nodemask)</td></tr>
<tr class="memdesc:a03781879a5c16360c1635004f5b3d0ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the memory allocation mask.  <a href="#a03781879a5c16360c1635004f5b3d0ce">More...</a><br /></td></tr>
<tr class="separator:a03781879a5c16360c1635004f5b3d0ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99fe7a1a08688f1bc6cded282e402a00"><td class="memItemLeft" align="right" valign="top">struct bitmap *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="alloc_8c.html#a99fe7a1a08688f1bc6cded282e402a00">numa_get_membind</a> (void)</td></tr>
<tr class="memdesc:a99fe7a1a08688f1bc6cded282e402a00"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the mask of nodes from which memory can currently be allocated.  <a href="#a99fe7a1a08688f1bc6cded282e402a00">More...</a><br /></td></tr>
<tr class="separator:a99fe7a1a08688f1bc6cded282e402a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd3db7ddd501d9e3cb85d584f93130ce"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="alloc_8c.html#acd3db7ddd501d9e3cb85d584f93130ce">numa_alloc_onnode</a> (size_t size, nodeid_t node, size_t pagesize)</td></tr>
<tr class="memdesc:acd3db7ddd501d9e3cb85d584f93130ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocates memory on a specific node.  <a href="#acd3db7ddd501d9e3cb85d584f93130ce">More...</a><br /></td></tr>
<tr class="separator:acd3db7ddd501d9e3cb85d584f93130ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f47a5441f8af42577bb7ca1be59718"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="alloc_8c.html#a30f47a5441f8af42577bb7ca1be59718">numa_alloc_local</a> (size_t size, size_t pagesize)</td></tr>
<tr class="memdesc:a30f47a5441f8af42577bb7ca1be59718"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocates size bytes of memory on the local node  <a href="#a30f47a5441f8af42577bb7ca1be59718">More...</a><br /></td></tr>
<tr class="separator:a30f47a5441f8af42577bb7ca1be59718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f99eadfe520a1dcd22fb8df721d4461"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="alloc_8c.html#a4f99eadfe520a1dcd22fb8df721d4461">numa_alloc_interleaved</a> (size_t size, size_t pagesize)</td></tr>
<tr class="memdesc:a4f99eadfe520a1dcd22fb8df721d4461"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocates size bytes of memory page interleaved on all nodes.  <a href="#a4f99eadfe520a1dcd22fb8df721d4461">More...</a><br /></td></tr>
<tr class="separator:a4f99eadfe520a1dcd22fb8df721d4461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5b5bb820e6f3b305c265a4a8c0081bb"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="alloc_8c.html#ad5b5bb820e6f3b305c265a4a8c0081bb">numa_alloc_interleaved_subset</a> (size_t size, size_t pagesize, struct bitmap *nodemask)</td></tr>
<tr class="memdesc:ad5b5bb820e6f3b305c265a4a8c0081bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocates size bytes of memory page interleaved the nodes specified in the nodemask.  <a href="#ad5b5bb820e6f3b305c265a4a8c0081bb">More...</a><br /></td></tr>
<tr class="separator:ad5b5bb820e6f3b305c265a4a8c0081bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd4f06373d27d21476015a416007b124"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="alloc_8c.html#acd4f06373d27d21476015a416007b124">numa_alloc</a> (size_t size, size_t pagesize)</td></tr>
<tr class="memdesc:acd4f06373d27d21476015a416007b124"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocates size bytes of memory with the current NUMA policy.  <a href="#acd4f06373d27d21476015a416007b124">More...</a><br /></td></tr>
<tr class="separator:acd4f06373d27d21476015a416007b124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c44a3a92bef81d63508374e66fa133a"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="alloc_8c.html#a1c44a3a92bef81d63508374e66fa133a">numa_realloc</a> (void *old_addr, size_t old_size, size_t new_size)</td></tr>
<tr class="memdesc:a1c44a3a92bef81d63508374e66fa133a"><td class="mdescLeft">&#160;</td><td class="mdescRight">changes the size of the memory area.  <a href="#a1c44a3a92bef81d63508374e66fa133a">More...</a><br /></td></tr>
<tr class="separator:a1c44a3a92bef81d63508374e66fa133a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5daf85598ac258583e4d370de3996052"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="alloc_8c.html#a5daf85598ac258583e4d370de3996052">numa_free</a> (void *start, size_t size)</td></tr>
<tr class="memdesc:a5daf85598ac258583e4d370de3996052"><td class="mdescLeft">&#160;</td><td class="mdescRight">frees size bytes of memory starting at start  <a href="#a5daf85598ac258583e4d370de3996052">More...</a><br /></td></tr>
<tr class="separator:a5daf85598ac258583e4d370de3996052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08290f2d8c7b6bbb437faf33d440100c"><td class="memItemLeft" align="right" valign="top">errval_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="alloc_8c.html#a08290f2d8c7b6bbb437faf33d440100c">numa_frame_alloc_on_node</a> (struct <a class="el" href="structcapref.html">capref</a> *dest, size_t size, nodeid_t node, size_t *ret_size)</td></tr>
<tr class="memdesc:a08290f2d8c7b6bbb437faf33d440100c"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocates a frame on a specific node  <a href="#a08290f2d8c7b6bbb437faf33d440100c">More...</a><br /></td></tr>
<tr class="separator:a08290f2d8c7b6bbb437faf33d440100c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8ca74c62c94baa1a85a2470209f25ce"><td class="memItemLeft" align="right" valign="top">errval_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="alloc_8c.html#ad8ca74c62c94baa1a85a2470209f25ce">numa_frame_free</a> (struct <a class="el" href="structcapref.html">capref</a> frame)</td></tr>
<tr class="memdesc:ad8ca74c62c94baa1a85a2470209f25ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">frees a previously allocated frame  <a href="#ad8ca74c62c94baa1a85a2470209f25ce">More...</a><br /></td></tr>
<tr class="separator:ad8ca74c62c94baa1a85a2470209f25ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e74f430630f05f1dbc12d45dc4638f6"><td class="memItemLeft" align="right" valign="top">errval_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="alloc_8c.html#a8e74f430630f05f1dbc12d45dc4638f6">numa_move_pages</a> (domainid_t did, size_t count, void **pages, const nodeid_t *nodes, errval_t *status, int flags)</td></tr>
<tr class="memdesc:a8e74f430630f05f1dbc12d45dc4638f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">moves a list of pages in the address space of the current domain  <a href="#a8e74f430630f05f1dbc12d45dc4638f6">More...</a><br /></td></tr>
<tr class="separator:a8e74f430630f05f1dbc12d45dc4638f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa268e8a2d18fa839340f83da097007f7"><td class="memItemLeft" align="right" valign="top">errval_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="alloc_8c.html#aa268e8a2d18fa839340f83da097007f7">numa_migrate_pages</a> (domainid_t did, struct bitmap *fromnodes, struct bitmap *tonodes)</td></tr>
<tr class="memdesc:aa268e8a2d18fa839340f83da097007f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">migrate a domain from one set of nodes to another  <a href="#aa268e8a2d18fa839340f83da097007f7">More...</a><br /></td></tr>
<tr class="separator:aa268e8a2d18fa839340f83da097007f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a9b08846094cd7eec99c3bb82e61a361d"><td class="memItemLeft" align="right" valign="top">struct bitmap *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="alloc_8c.html#a9b08846094cd7eec99c3bb82e61a361d">numa_alloc_interleave_mask</a></td></tr>
<tr class="memdesc:a9b08846094cd7eec99c3bb82e61a361d"><td class="mdescLeft">&#160;</td><td class="mdescRight">&lt; numa interleave mask for allocations  <a href="#a9b08846094cd7eec99c3bb82e61a361d">More...</a><br /></td></tr>
<tr class="separator:a9b08846094cd7eec99c3bb82e61a361d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>General Numa functions. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="acd4f06373d27d21476015a416007b124"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* numa_alloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pagesize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>allocates size bytes of memory with the current NUMA policy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>size of the memory region in bytes </td></tr>
    <tr><td class="paramname">pagesize</td><td>preferred page size to be used </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the mapped memory region</dd></dl>
<p>The memory must be freed with <a class="el" href="alloc_8c.html#a5daf85598ac258583e4d370de3996052" title="frees size bytes of memory starting at start ">numa_free()</a>. On errors NULL is returned. </p>

</div>
</div>
<a class="anchor" id="a4f99eadfe520a1dcd22fb8df721d4461"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* numa_alloc_interleaved </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pagesize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>allocates size bytes of memory page interleaved on all nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>size of the memory region in bytes </td></tr>
    <tr><td class="paramname">pagesize</td><td>preferred page size to be used</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the mapped memory region</dd></dl>
<p>should only be used for large areas consisting of multiple pages. The memory must be freed with <a class="el" href="alloc_8c.html#a5daf85598ac258583e4d370de3996052" title="frees size bytes of memory starting at start ">numa_free()</a>. On errors NULL is returned. </p>

</div>
</div>
<a class="anchor" id="ad5b5bb820e6f3b305c265a4a8c0081bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* numa_alloc_interleaved_subset </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pagesize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct bitmap *&#160;</td>
          <td class="paramname"><em>nodemask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>allocates size bytes of memory page interleaved the nodes specified in the nodemask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>size of the memory region in bytes </td></tr>
    <tr><td class="paramname">nodemask</td><td>subset of nodes to consider for allocation </td></tr>
    <tr><td class="paramname">pagesize</td><td>preferred page size to be used</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the mapped memory region</dd></dl>
<p>should only be used for large areas consisting of multiple pages. The memory must be freed with <a class="el" href="alloc_8c.html#a5daf85598ac258583e4d370de3996052" title="frees size bytes of memory starting at start ">numa_free()</a>. On errors NULL is returned. </p>

</div>
</div>
<a class="anchor" id="a30f47a5441f8af42577bb7ca1be59718"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* numa_alloc_local </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pagesize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>allocates size bytes of memory on the local node </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>size of the memory region in bytes </td></tr>
    <tr><td class="paramname">pagesize</td><td>page size to be used for the mapping</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to memory region</dd></dl>
<p>The memory must be freed with <a class="el" href="alloc_8c.html#a5daf85598ac258583e4d370de3996052" title="frees size bytes of memory starting at start ">numa_free()</a>. On errors NULL is returned. </p>

</div>
</div>
<a class="anchor" id="acd3db7ddd501d9e3cb85d584f93130ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* numa_alloc_onnode </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nodeid_t&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pagesize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>allocates memory on a specific node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>size of the region in bytes </td></tr>
    <tr><td class="paramname">node</td><td>ID of the node to allocate from </td></tr>
    <tr><td class="paramname">pagesize</td><td>page size to be used for the mapping</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to memory region</dd></dl>
<p>The size argument will be rounded up to a multiple of the system page size. if the specified node is externally denied to this process, this call will fail. The memory must be freed with <a class="el" href="alloc_8c.html#a5daf85598ac258583e4d370de3996052" title="frees size bytes of memory starting at start ">numa_free()</a>. On errors NULL is returned. </p>

</div>
</div>
<a class="anchor" id="a02df68ef54915fb3dd10e4ad761fc690"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void numa_bind </td>
          <td>(</td>
          <td class="paramtype">struct bitmap *&#160;</td>
          <td class="paramname"><em>nodemask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>binds the current task and its children to the nodes specified in nodemask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodemask</td><td>bitmap representing the nodes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a08290f2d8c7b6bbb437faf33d440100c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">errval_t numa_frame_alloc_on_node </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcapref.html">capref</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nodeid_t&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>ret_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>allocates a frame on a specific node </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>capref to store the frame </td></tr>
    <tr><td class="paramname">size</td><td>size of the frame to allocated </td></tr>
    <tr><td class="paramname">node</td><td>node on which the frame should be allocated </td></tr>
    <tr><td class="paramname">ret_size</td><td>returned size of the frame capability</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SYS_ERR_OK on SUCCESS errval on FAILURE </dd></dl>

</div>
</div>
<a class="anchor" id="ad8ca74c62c94baa1a85a2470209f25ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">errval_t numa_frame_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcapref.html">capref</a>&#160;</td>
          <td class="paramname"><em>frame</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>frees a previously allocated frame </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame</td><td>capability to free </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5daf85598ac258583e4d370de3996052"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void numa_free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>frees size bytes of memory starting at start </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>start of the memory region </td></tr>
    <tr><td class="paramname">size</td><td>number of bytes to free</td></tr>
  </table>
  </dd>
</dl>
<p>the memory must be previously allocated by one of the numa_alloc* functions </p>

</div>
</div>
<a class="anchor" id="a16ed82504021427c568854931c11bc3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct bitmap* numa_get_interleave_mask </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the current interleave mask </p>
<dl class="section return"><dt>Returns</dt><dd>bitmask representing the current interleave state</dd></dl>
<p>returns the current interleave mask if the task's memory allocation policy is page interleaved. Otherwise, this function returns an empty mask. </p>

</div>
</div>
<a class="anchor" id="a99fe7a1a08688f1bc6cded282e402a00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct bitmap* numa_get_membind </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the mask of nodes from which memory can currently be allocated. </p>
<dl class="section return"><dt>Returns</dt><dd>bitmap of nodes from which can be allocated </dd></dl>

</div>
</div>
<a class="anchor" id="aa268e8a2d18fa839340f83da097007f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">errval_t numa_migrate_pages </td>
          <td>(</td>
          <td class="paramtype">domainid_t&#160;</td>
          <td class="paramname"><em>did</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct bitmap *&#160;</td>
          <td class="paramname"><em>fromnodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct bitmap *&#160;</td>
          <td class="paramname"><em>tonodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>migrate a domain from one set of nodes to another </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">did</td><td>the domain ID </td></tr>
    <tr><td class="paramname">fromnodes</td><td>bitmap representing the current nodes </td></tr>
    <tr><td class="paramname">tonodes</td><td>bitmap representing the</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SYS_ERR_OK on SUCCESS </dd></dl>

</div>
</div>
<a class="anchor" id="a8e74f430630f05f1dbc12d45dc4638f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">errval_t numa_move_pages </td>
          <td>(</td>
          <td class="paramtype">domainid_t&#160;</td>
          <td class="paramname"><em>did</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>pages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const nodeid_t *&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">errval_t *&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>moves a list of pages in the address space of the current domain </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">did</td><td>the domain ID </td></tr>
    <tr><td class="paramname">count</td><td>number of pages to move </td></tr>
    <tr><td class="paramname">pages</td><td>list of pages </td></tr>
    <tr><td class="paramname">nodes</td><td>list of nodes to which the pages can be moved </td></tr>
    <tr><td class="paramname">status</td><td>returns the outcome for each page </td></tr>
    <tr><td class="paramname">flags</td><td>flags for moving the pages</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SYS_ERR_OK on SUCCESS </dd></dl>

</div>
</div>
<a class="anchor" id="a1c44a3a92bef81d63508374e66fa133a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* numa_realloc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>old_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>old_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>new_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>changes the size of the memory area. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">old_addr</td><td>pointer ot the old memory region </td></tr>
    <tr><td class="paramname">old_size</td><td>size of the old memory region </td></tr>
    <tr><td class="paramname">new_size</td><td>new size to allocate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4d9646ec73af0a36cdd00302da6aeb0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void numa_set_interleave_mask </td>
          <td>(</td>
          <td class="paramtype">struct bitmap *&#160;</td>
          <td class="paramname"><em>nodemask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sets the memory interleave mask for the current task to nodemask </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodemask</td><td>bitmask representing the nodes</td></tr>
  </table>
  </dd>
</dl>
<p>All new memory allocations are page interleaved over all nodes in the interleave mask. Interleaving can be turned off again by passing an empty mask.</p>
<p>This bitmask is considered to be a hint. Fallback to other nodes may be possible </p>

</div>
</div>
<a class="anchor" id="a03781879a5c16360c1635004f5b3d0ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">errval_t numa_set_membind </td>
          <td>(</td>
          <td class="paramtype">struct bitmap *&#160;</td>
          <td class="paramname"><em>nodemask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sets the memory allocation mask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodemask</td><td>bitmap representing the nodes</td></tr>
  </table>
  </dd>
</dl>
<p>The task will only allocate memory from the nodes set in nodemask.</p>
<p>an empty mask or not allowed nodes in the mask will result in an error </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a9b08846094cd7eec99c3bb82e61a361d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct bitmap* numa_alloc_interleave_mask</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>&lt; numa interleave mask for allocations </p>
<p>numa bind mask for allocations </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
