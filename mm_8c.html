<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Barrelfish: lib/mm/mm.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Barrelfish
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_192d042fcd4c3f2c10caf81b96db23cd.html">mm</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">mm.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Memory manager.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad761ed5f195f471077918c0b0f8e6e76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mm_8c.html#ad761ed5f195f471077918c0b0f8e6e76">mm_debug_print</a> (struct <a class="el" href="structmmnode.html">mmnode</a> *<a class="el" href="structmmnode.html">mmnode</a>, int space)</td></tr>
<tr class="memdesc:ad761ed5f195f471077918c0b0f8e6e76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Debug printout of the status of all nodes.  <a href="#ad761ed5f195f471077918c0b0f8e6e76">More...</a><br /></td></tr>
<tr class="separator:ad761ed5f195f471077918c0b0f8e6e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3df8a52b05f16e2e3a458b50b3682eb8"><td class="memItemLeft" align="right" valign="top">errval_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mm_8c.html#a3df8a52b05f16e2e3a458b50b3682eb8">mm_init</a> (struct <a class="el" href="structmm.html">mm</a> *<a class="el" href="structmm.html">mm</a>, enum objtype objtype, genpaddr_t base, uint8_t sizebits, uint8_t maxchildbits, slab_refill_func_t slab_refill_func, <a class="el" href="mm_2slot__alloc_8h.html#a8fdc29ca977942f52fb34a3dd504e590">slot_alloc_t</a> slot_alloc_func, slot_refill_t slot_refill_func, void *slot_alloc_inst, bool delete_chunked)</td></tr>
<tr class="memdesc:a3df8a52b05f16e2e3a458b50b3682eb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise a memory manager instance.  <a href="#a3df8a52b05f16e2e3a458b50b3682eb8">More...</a><br /></td></tr>
<tr class="separator:a3df8a52b05f16e2e3a458b50b3682eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48256f62c9f9bc46bb72349cf18e2cce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mm_8c.html#a48256f62c9f9bc46bb72349cf18e2cce">mm_destroy</a> (struct <a class="el" href="structmm.html">mm</a> *<a class="el" href="structmm.html">mm</a>)</td></tr>
<tr class="memdesc:a48256f62c9f9bc46bb72349cf18e2cce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a memory manager instance.  <a href="#a48256f62c9f9bc46bb72349cf18e2cce">More...</a><br /></td></tr>
<tr class="separator:a48256f62c9f9bc46bb72349cf18e2cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0e0aa895ef3990422b86d32fe8dd24e"><td class="memItemLeft" align="right" valign="top">errval_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mm_8c.html#ab0e0aa895ef3990422b86d32fe8dd24e">mm_add</a> (struct <a class="el" href="structmm.html">mm</a> *<a class="el" href="structmm.html">mm</a>, struct <a class="el" href="structcapref.html">capref</a> cap, uint8_t sizebits, genpaddr_t base)</td></tr>
<tr class="memdesc:ab0e0aa895ef3990422b86d32fe8dd24e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new region to the memory manager.  <a href="#ab0e0aa895ef3990422b86d32fe8dd24e">More...</a><br /></td></tr>
<tr class="separator:ab0e0aa895ef3990422b86d32fe8dd24e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a3bdca7c421812e46b401904a950f2e"><td class="memItemLeft" align="right" valign="top">errval_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mm_8c.html#a2a3bdca7c421812e46b401904a950f2e">mm_add_multi</a> (struct <a class="el" href="structmm.html">mm</a> *<a class="el" href="structmm.html">mm</a>, struct <a class="el" href="structcapref.html">capref</a> cap, gensize_t size, genpaddr_t base)</td></tr>
<tr class="memdesc:a2a3bdca7c421812e46b401904a950f2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new region to the memory manager. The region does not need to be power-of-two sized or aligned.  <a href="#a2a3bdca7c421812e46b401904a950f2e">More...</a><br /></td></tr>
<tr class="separator:a2a3bdca7c421812e46b401904a950f2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1de7224804fad28ace8056b4bd6034ae"><td class="memItemLeft" align="right" valign="top">errval_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mm_8c.html#a1de7224804fad28ace8056b4bd6034ae">mm_alloc</a> (struct <a class="el" href="structmm.html">mm</a> *<a class="el" href="structmm.html">mm</a>, uint8_t sizebits, struct <a class="el" href="structcapref.html">capref</a> *retcap, genpaddr_t *retbase)</td></tr>
<tr class="memdesc:a1de7224804fad28ace8056b4bd6034ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate an arbitrary memory region of a given size.  <a href="#a1de7224804fad28ace8056b4bd6034ae">More...</a><br /></td></tr>
<tr class="separator:a1de7224804fad28ace8056b4bd6034ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91d5e5f8b8ea9058bdc0f09e2481b781"><td class="memItemLeft" align="right" valign="top">errval_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mm_8c.html#a91d5e5f8b8ea9058bdc0f09e2481b781">mm_alloc_range</a> (struct <a class="el" href="structmm.html">mm</a> *<a class="el" href="structmm.html">mm</a>, uint8_t sizebits, genpaddr_t minbase, genpaddr_t maxlimit, struct <a class="el" href="structcapref.html">capref</a> *retcap, genpaddr_t *retbase)</td></tr>
<tr class="memdesc:a91d5e5f8b8ea9058bdc0f09e2481b781"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory region of a given size within a given address range.  <a href="#a91d5e5f8b8ea9058bdc0f09e2481b781">More...</a><br /></td></tr>
<tr class="separator:a91d5e5f8b8ea9058bdc0f09e2481b781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad911a34da397778f07641932289bc4ec"><td class="memItemLeft" align="right" valign="top">errval_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mm_8c.html#ad911a34da397778f07641932289bc4ec">mm_realloc_range</a> (struct <a class="el" href="structmm.html">mm</a> *<a class="el" href="structmm.html">mm</a>, uint8_t sizebits, genpaddr_t base, struct <a class="el" href="structcapref.html">capref</a> *retcap)</td></tr>
<tr class="memdesc:ad911a34da397778f07641932289bc4ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return cap to a specific region, that may be partially allocated.  <a href="#ad911a34da397778f07641932289bc4ec">More...</a><br /></td></tr>
<tr class="separator:ad911a34da397778f07641932289bc4ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2747bdb0b3366ef5ca625ca3baace7ac"><td class="memItemLeft" align="right" valign="top">errval_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mm_8c.html#a2747bdb0b3366ef5ca625ca3baace7ac">mm_free</a> (struct <a class="el" href="structmm.html">mm</a> *<a class="el" href="structmm.html">mm</a>, struct <a class="el" href="structcapref.html">capref</a> cap, genpaddr_t base, uint8_t sizebits)</td></tr>
<tr class="memdesc:a2747bdb0b3366ef5ca625ca3baace7ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free an allocated region.  <a href="#a2747bdb0b3366ef5ca625ca3baace7ac">More...</a><br /></td></tr>
<tr class="separator:a2747bdb0b3366ef5ca625ca3baace7ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9aec842af1eddd53c25dff8b6dcb388"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mm_8c.html#af9aec842af1eddd53c25dff8b6dcb388">mm_relinquish_all</a> (struct <a class="el" href="structmm.html">mm</a> *<a class="el" href="structmm.html">mm</a>, struct <a class="el" href="structmem__cap.html">mem_cap</a> *ret, size_t retlen)</td></tr>
<tr class="memdesc:af9aec842af1eddd53c25dff8b6dcb388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills an array with metadata for all free regions.  <a href="#af9aec842af1eddd53c25dff8b6dcb388">More...</a><br /></td></tr>
<tr class="separator:af9aec842af1eddd53c25dff8b6dcb388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dc346d391842d7e09487f418a604e26"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mm_8c.html#a9dc346d391842d7e09487f418a604e26">mm_relinquish_range</a> (struct <a class="el" href="structmm.html">mm</a> *<a class="el" href="structmm.html">mm</a>, genpaddr_t base, genpaddr_t limit, struct <a class="el" href="structmem__cap.html">mem_cap</a> *ret, size_t retlen)</td></tr>
<tr class="memdesc:a9dc346d391842d7e09487f418a604e26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills an array with metadata for all free regions within a given range.  <a href="#a9dc346d391842d7e09487f418a604e26">More...</a><br /></td></tr>
<tr class="separator:a9dc346d391842d7e09487f418a604e26"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Memory manager. </p>
<p>This code manages memory regions (which may refer to actual RAM, or physical address space, or other spaces) and the capabilities to those regions.</p>
<p>The meta-data is structured as a B-tree. Every node has a variable power-of-two-sized number of children (up to a limit fixed at initialisation time), which is stored in the node itself (as "childbits"). Nodes without any children have childbits = -1 (FLAGBITS).</p>
<p>The position of a node in the tree exactly determines its size and address relative to the size and address of the region being managed by the allocator (all sizes must be powers of two).</p>
<p>A node may be one of four types (see <a class="el" href="mm_8h.html#a618f7f5866526d01adfc6c50c3250898">nodetype</a>): 0. A "dummy" node, which exists structurally in the tree, but for which we do not have a capability (ie. the region is incomplete).</p><ol type="1">
<li>A "chunked" node, for which we have a capability, but which has been split up into child nodes for smaller allocations.</li>
<li>A free node, which is a regular free child node in the tree.</li>
<li>An allocated node. </li>
</ol>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ab0e0aa895ef3990422b86d32fe8dd24e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">errval_t mm_add </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structmm.html">mm</a> *&#160;</td>
          <td class="paramname"><em>mm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcapref.html">capref</a>&#160;</td>
          <td class="paramname"><em>cap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>sizebits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">genpaddr_t&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a new region to the memory manager. </p>
<p>It is an error if any part of the region has already been added, or the region doesn't fit within the base and size specified for the allocator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mm</td><td>Memory manager instance </td></tr>
    <tr><td class="paramname">cap</td><td>Capability to newly-added region </td></tr>
    <tr><td class="paramname">sizebits</td><td>Size of region </td></tr>
    <tr><td class="paramname">base</td><td>Physical base address of region </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2a3bdca7c421812e46b401904a950f2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">errval_t mm_add_multi </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structmm.html">mm</a> *&#160;</td>
          <td class="paramname"><em>mm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcapref.html">capref</a>&#160;</td>
          <td class="paramname"><em>cap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gensize_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">genpaddr_t&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a new region to the memory manager. The region does not need to be power-of-two sized or aligned. </p>
<p>It is an error if any part of the region has already been added, or the region doesn't fit within the base and size specified for the allocator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mm</td><td>Memory manager instance </td></tr>
    <tr><td class="paramname">cap</td><td>Capability to newly-added region </td></tr>
    <tr><td class="paramname">size</td><td>Size of region </td></tr>
    <tr><td class="paramname">base</td><td>Physical base address of region </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1de7224804fad28ace8056b4bd6034ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">errval_t mm_alloc </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structmm.html">mm</a> *&#160;</td>
          <td class="paramname"><em>mm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>sizebits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcapref.html">capref</a> *&#160;</td>
          <td class="paramname"><em>retcap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">genpaddr_t *&#160;</td>
          <td class="paramname"><em>retbase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate an arbitrary memory region of a given size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mm</td><td>Memory manager instance </td></tr>
    <tr><td class="paramname">sizebits</td><td>Size of requested region </td></tr>
    <tr><td class="paramname">retcap</td><td>Pointer to capref struct, to be filled-in </td></tr>
    <tr><td class="paramname">retbase</td><td>If non-NULL, the base address of the allocated region is returned here </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a91d5e5f8b8ea9058bdc0f09e2481b781"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">errval_t mm_alloc_range </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structmm.html">mm</a> *&#160;</td>
          <td class="paramname"><em>mm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>sizebits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">genpaddr_t&#160;</td>
          <td class="paramname"><em>minbase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">genpaddr_t&#160;</td>
          <td class="paramname"><em>maxlimit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcapref.html">capref</a> *&#160;</td>
          <td class="paramname"><em>retcap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">genpaddr_t *&#160;</td>
          <td class="paramname"><em>retbase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate memory region of a given size within a given address range. </p>
<p>If this call succeeds, it must be the case that: *retbase &gt;= minbase &amp;&amp; *retbase + (1UL &lt;&lt; sizebits) &lt;= maxlimit</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mm</td><td>Memory manager instance </td></tr>
    <tr><td class="paramname">sizebits</td><td>Size of requested region </td></tr>
    <tr><td class="paramname">minbase</td><td>Minimum base address of region to allocate </td></tr>
    <tr><td class="paramname">maxlimit</td><td>Maximum limit address of region to allocate </td></tr>
    <tr><td class="paramname">retcap</td><td>Pointer to capref struct, to be filled-in </td></tr>
    <tr><td class="paramname">retbase</td><td>If non-NULL, the base address of the allocated region is returned here </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad761ed5f195f471077918c0b0f8e6e76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mm_debug_print </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structmmnode.html">mmnode</a> *&#160;</td>
          <td class="paramname"><em>mmnode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>space</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Debug printout of the status of all nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mmnode</td><td>Struct mmnode to print from </td></tr>
    <tr><td class="paramname">space</td><td>Call with 0, used to track depth for pretty printing </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a48256f62c9f9bc46bb72349cf18e2cce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mm_destroy </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structmm.html">mm</a> *&#160;</td>
          <td class="paramname"><em>mm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a memory manager instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mm</td><td>Memory manager instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2747bdb0b3366ef5ca625ca3baace7ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">errval_t mm_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structmm.html">mm</a> *&#160;</td>
          <td class="paramname"><em>mm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcapref.html">capref</a>&#160;</td>
          <td class="paramname"><em>cap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">genpaddr_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>sizebits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free an allocated region. </p>
<p>Marks the region (which must previously have been allocated) as free.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mm</td><td>Memory manager instance </td></tr>
    <tr><td class="paramname">cap</td><td>Cap to re-insert (specify NULL_CAP if delete_chunked == false) </td></tr>
    <tr><td class="paramname">base</td><td>Physical base address of region </td></tr>
    <tr><td class="paramname">sizebits</td><td>Size of region </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3df8a52b05f16e2e3a458b50b3682eb8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">errval_t mm_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structmm.html">mm</a> *&#160;</td>
          <td class="paramname"><em>mm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum objtype objtype&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">genpaddr_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>sizebits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>maxchildbits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">slab_refill_func_t&#160;</td>
          <td class="paramname"><em>slab_refill_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mm_2slot__alloc_8h.html#a8fdc29ca977942f52fb34a3dd504e590">slot_alloc_t</a>&#160;</td>
          <td class="paramname"><em>slot_alloc_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">slot_refill_t&#160;</td>
          <td class="paramname"><em>slot_refill_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>slot_alloc_inst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>delete_chunked</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise a memory manager instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mm</td><td>Pointer to memory manager instance, to be filled-in </td></tr>
    <tr><td class="paramname">objtype</td><td>Kernel object type to be managed </td></tr>
    <tr><td class="paramname">base</td><td>Base address of region to be managed </td></tr>
    <tr><td class="paramname">sizebits</td><td>Size (in bits) of region to be managed </td></tr>
    <tr><td class="paramname">maxchildbits</td><td>Maximum number of children (in bits) at each node </td></tr>
    <tr><td class="paramname">slab_refill_func</td><td>Function to be used to refill slab allocator If this is NULL, the caller must provide static storage with slab_grow. </td></tr>
    <tr><td class="paramname">slot_alloc_func</td><td>Slot allocator function </td></tr>
    <tr><td class="paramname">slot_refill_func</td><td>Slot allocator refill function </td></tr>
    <tr><td class="paramname">slot_alloc_inst</td><td>Slot allocator opaque instance pointer </td></tr>
    <tr><td class="paramname">delete_chunked</td><td>Whether to delete chunked caps</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Setting maxchildbits &gt; 1 saves substantial space, but may lead to the situation where an allocation request cannot be satisfied despite memory being available, because the memory has been chunked up into smaller caps that, while free, cannot be recombined without revoking existing allocations. </dd></dl>

</div>
</div>
<a class="anchor" id="ad911a34da397778f07641932289bc4ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">errval_t mm_realloc_range </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structmm.html">mm</a> *&#160;</td>
          <td class="paramname"><em>mm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>sizebits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">genpaddr_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcapref.html">capref</a> *&#160;</td>
          <td class="paramname"><em>retcap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return cap to a specific region, that may be partially allocated. </p>
<p>The parameters to this function specify a fixed memory region (base and size) that may overlap one or more already-allocated memory regions. It marks the entire region as allocated, returning a cap to it.</p>
<dl class="section warning"><dt>Warning</dt><dd>It is assumed that the caller knows what they are doing.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mm</td><td>Memory manager instance </td></tr>
    <tr><td class="paramname">sizebits</td><td>Size of region </td></tr>
    <tr><td class="paramname">base</td><td>Base address of region </td></tr>
    <tr><td class="paramname">retcap</td><td>Pointer to capref struct, to be filled-in </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af9aec842af1eddd53c25dff8b6dcb388"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mm_relinquish_all </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structmm.html">mm</a> *&#160;</td>
          <td class="paramname"><em>mm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structmem__cap.html">mem_cap</a> *&#160;</td>
          <td class="paramname"><em>ret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>retlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills an array with metadata for all free regions. </p>
<p>The regions returned are marked as allocated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mm</td><td>Memory manager instance </td></tr>
    <tr><td class="paramname">ret</td><td>Pointer to return array to be filled-in </td></tr>
    <tr><td class="paramname">retlen</td><td>Length of the array, in slots</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of caps that could have been stored in the return array. If this is less than or equal to #retlen, all caps have been returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a9dc346d391842d7e09487f418a604e26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mm_relinquish_range </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structmm.html">mm</a> *&#160;</td>
          <td class="paramname"><em>mm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">genpaddr_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">genpaddr_t&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structmem__cap.html">mem_cap</a> *&#160;</td>
          <td class="paramname"><em>ret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>retlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills an array with metadata for all free regions within a given range. </p>
<p>The regions returned are marked as allocated.</p>
<p>It must be the case for every returned cap (i) that: ret[i]-&gt;base &gt;= base &amp;&amp; ret[i]-&gt;base + (1UL &lt;&lt; ret[i]-&gt;sizebits) &lt;= limit</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mm</td><td>Memory manager instance </td></tr>
    <tr><td class="paramname">base</td><td>Base address of range from which to relinquish memory </td></tr>
    <tr><td class="paramname">limit</td><td>Limit address of range from which to relinquish memory </td></tr>
    <tr><td class="paramname">ret</td><td>Pointer to return array to be filled-in </td></tr>
    <tr><td class="paramname">retlen</td><td>Length of the array, in slots</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of caps that could have been stored in the return array. If this is less than or equal to #retlen, all caps have been returned. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
