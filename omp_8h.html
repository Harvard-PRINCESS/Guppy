<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Barrelfish: include/omp.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Barrelfish
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">omp.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Include to use the bomp library.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct____omp__lock.html">__omp_lock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal declaration of a simple lock  <a href="struct____omp__lock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a1396d4ac5ba3b8fb5b92339e2ba97d7a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="omp_8h.html#a1396d4ac5ba3b8fb5b92339e2ba97d7a">OMP_VERSION_31</a>&#160;&#160;&#160;0x0310</td></tr>
<tr class="separator:a1396d4ac5ba3b8fb5b92339e2ba97d7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72a8d7648c505fb761f775380306a11e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a72a8d7648c505fb761f775380306a11e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="omp_8h.html#a72a8d7648c505fb761f775380306a11e">BOMP_DEFAULT_STACKSIZE</a>&#160;&#160;&#160;(64 * 1024)</td></tr>
<tr class="memdesc:a72a8d7648c505fb761f775380306a11e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag indicating that all threads should be used. <br /></td></tr>
<tr class="separator:a72a8d7648c505fb761f775380306a11e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ab7d4cb9bf8de53f6e23648e4f541a893"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="omp_8h.html#ab74053fd9c5f0b0d4136be24d7d55098">bomp_backend</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="omp_8h.html#ab7d4cb9bf8de53f6e23648e4f541a893">bomp_backend_t</a></td></tr>
<tr class="separator:ab7d4cb9bf8de53f6e23648e4f541a893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16bc19799524d5136341fa89b2662731"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="omp_8h.html#ab705b3379866fe5ef19518ef9185c06f">omp_sched</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="omp_8h.html#a16bc19799524d5136341fa89b2662731">omp_sched_t</a></td></tr>
<tr class="separator:a16bc19799524d5136341fa89b2662731"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac7a88583c6bdea6764c51982239b35c1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="omp_8h.html#ac7a88583c6bdea6764c51982239b35c1">bomp_switch_backend</a> (<a class="el" href="omp_8h.html#ab7d4cb9bf8de53f6e23648e4f541a893">bomp_backend_t</a> backend)</td></tr>
<tr class="memdesc:ac7a88583c6bdea6764c51982239b35c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">switches the backend to be used  <a href="#ac7a88583c6bdea6764c51982239b35c1">More...</a><br /></td></tr>
<tr class="separator:ac7a88583c6bdea6764c51982239b35c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a663cb7186ea9b0b88751fb571ddb9570"><td class="memItemLeft" align="right" valign="top"><a class="el" href="omp_8h.html#ab7d4cb9bf8de53f6e23648e4f541a893">bomp_backend_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="omp_8h.html#a663cb7186ea9b0b88751fb571ddb9570">bomp_get_backend</a> (void)</td></tr>
<tr class="memdesc:a663cb7186ea9b0b88751fb571ddb9570"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets the currently enabled backend  <a href="#a663cb7186ea9b0b88751fb571ddb9570">More...</a><br /></td></tr>
<tr class="separator:a663cb7186ea9b0b88751fb571ddb9570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af43677538d4bbe4be9732b0fb7ed7f25"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="omp_8h.html#af43677538d4bbe4be9732b0fb7ed7f25">bomp_init_cores</a> (void *coresbm, size_t stack_size)</td></tr>
<tr class="memdesc:af43677538d4bbe4be9732b0fb7ed7f25"><td class="mdescLeft">&#160;</td><td class="mdescRight">initializes the BOMP library using the indicated cores of the BM  <a href="#af43677538d4bbe4be9732b0fb7ed7f25">More...</a><br /></td></tr>
<tr class="separator:af43677538d4bbe4be9732b0fb7ed7f25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9f7ac801da9b75e7f49e5a2b28e8c84"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="omp_8h.html#af9f7ac801da9b75e7f49e5a2b28e8c84">bomp_init_varstack</a> (unsigned int nthreads, size_t stack_size)</td></tr>
<tr class="memdesc:af9f7ac801da9b75e7f49e5a2b28e8c84"><td class="mdescLeft">&#160;</td><td class="mdescRight">initializes the BOMP library with the given stack sizes  <a href="#af9f7ac801da9b75e7f49e5a2b28e8c84">More...</a><br /></td></tr>
<tr class="separator:af9f7ac801da9b75e7f49e5a2b28e8c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2a1aadbe72ac6b1f9aed9a2ef8e0044"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="omp_8h.html#ab2a1aadbe72ac6b1f9aed9a2ef8e0044">omp_set_num_threads</a> (int num_threads)</td></tr>
<tr class="memdesc:ab2a1aadbe72ac6b1f9aed9a2ef8e0044"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the number of threads to be used for parallel regions.  <a href="#ab2a1aadbe72ac6b1f9aed9a2ef8e0044">More...</a><br /></td></tr>
<tr class="separator:ab2a1aadbe72ac6b1f9aed9a2ef8e0044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ed0474735f00e49f9e37e8c76e935e5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="omp_8h.html#a9ed0474735f00e49f9e37e8c76e935e5">omp_get_num_threads</a> (void)</td></tr>
<tr class="memdesc:a9ed0474735f00e49f9e37e8c76e935e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the current number of threads used (innermost parallel region)  <a href="#a9ed0474735f00e49f9e37e8c76e935e5">More...</a><br /></td></tr>
<tr class="separator:a9ed0474735f00e49f9e37e8c76e935e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa00d2b875207d14eba24b62e65e795dd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="omp_8h.html#aa00d2b875207d14eba24b62e65e795dd">omp_get_max_threads</a> (void)</td></tr>
<tr class="memdesc:aa00d2b875207d14eba24b62e65e795dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">the maximum number of threads that can be used for a new parallel task  <a href="#aa00d2b875207d14eba24b62e65e795dd">More...</a><br /></td></tr>
<tr class="separator:aa00d2b875207d14eba24b62e65e795dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd4d1cfdcccf111a8ab472b1fef44d7f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="omp_8h.html#afd4d1cfdcccf111a8ab472b1fef44d7f">omp_get_thread_num</a> (void)</td></tr>
<tr class="memdesc:afd4d1cfdcccf111a8ab472b1fef44d7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the thread number of the calling thread within the current team.  <a href="#afd4d1cfdcccf111a8ab472b1fef44d7f">More...</a><br /></td></tr>
<tr class="separator:afd4d1cfdcccf111a8ab472b1fef44d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a669d6cb8c2e92e8b13df20e9c089f730"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="omp_8h.html#a669d6cb8c2e92e8b13df20e9c089f730">omp_get_num_procs</a> (void)</td></tr>
<tr class="memdesc:a669d6cb8c2e92e8b13df20e9c089f730"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the number of available processors  <a href="#a669d6cb8c2e92e8b13df20e9c089f730">More...</a><br /></td></tr>
<tr class="separator:a669d6cb8c2e92e8b13df20e9c089f730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc9d0c25c3e17b17c0b5c53d87f0d36d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="omp_8h.html#afc9d0c25c3e17b17c0b5c53d87f0d36d">omp_in_parallel</a> (void)</td></tr>
<tr class="memdesc:afc9d0c25c3e17b17c0b5c53d87f0d36d"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks if we are currently in a parallel region  <a href="#afc9d0c25c3e17b17c0b5c53d87f0d36d">More...</a><br /></td></tr>
<tr class="separator:afc9d0c25c3e17b17c0b5c53d87f0d36d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab681c69825d871dadd372aed316919ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="omp_8h.html#ab681c69825d871dadd372aed316919ae">omp_set_dynamic</a> (int dynamic_threads)</td></tr>
<tr class="memdesc:ab681c69825d871dadd372aed316919ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">enables / disables the dynamic behavior  <a href="#ab681c69825d871dadd372aed316919ae">More...</a><br /></td></tr>
<tr class="separator:ab681c69825d871dadd372aed316919ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6a3613a1eb4247a2f419c194df7f5df"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="omp_8h.html#af6a3613a1eb4247a2f419c194df7f5df">omp_get_dynamic</a> (void)</td></tr>
<tr class="memdesc:af6a3613a1eb4247a2f419c194df7f5df"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks if the dynamic behavior is enabled for the current task  <a href="#af6a3613a1eb4247a2f419c194df7f5df">More...</a><br /></td></tr>
<tr class="separator:af6a3613a1eb4247a2f419c194df7f5df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a371bb992a1b3b50415ba10614f52e1e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="omp_8h.html#a371bb992a1b3b50415ba10614f52e1e7">omp_set_nested</a> (int nested)</td></tr>
<tr class="memdesc:a371bb992a1b3b50415ba10614f52e1e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables or disables nested parallelism, by setting the nest-var ICV.  <a href="#a371bb992a1b3b50415ba10614f52e1e7">More...</a><br /></td></tr>
<tr class="separator:a371bb992a1b3b50415ba10614f52e1e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ac016a437ca14b410b4acf04af76257"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="omp_8h.html#a1ac016a437ca14b410b4acf04af76257">omp_get_nested</a> (void)</td></tr>
<tr class="memdesc:a1ac016a437ca14b410b4acf04af76257"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks if the nested behavior is enabled  <a href="#a1ac016a437ca14b410b4acf04af76257">More...</a><br /></td></tr>
<tr class="separator:a1ac016a437ca14b410b4acf04af76257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f122914c4e1c1a7a8e77fa711dec436"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="omp_8h.html#a8f122914c4e1c1a7a8e77fa711dec436">omp_set_schedule</a> (<a class="el" href="omp_8h.html#a16bc19799524d5136341fa89b2662731">omp_sched_t</a> kind, int modifier)</td></tr>
<tr class="memdesc:a8f122914c4e1c1a7a8e77fa711dec436"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the schedule to be used  <a href="#a8f122914c4e1c1a7a8e77fa711dec436">More...</a><br /></td></tr>
<tr class="separator:a8f122914c4e1c1a7a8e77fa711dec436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fd28034805870f3d3ed56822640e44a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="omp_8h.html#a2fd28034805870f3d3ed56822640e44a">omp_get_schedule</a> (<a class="el" href="omp_8h.html#a16bc19799524d5136341fa89b2662731">omp_sched_t</a> *kind, int *modifier)</td></tr>
<tr class="memdesc:a2fd28034805870f3d3ed56822640e44a"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the current scheduler settings  <a href="#a2fd28034805870f3d3ed56822640e44a">More...</a><br /></td></tr>
<tr class="separator:a2fd28034805870f3d3ed56822640e44a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61a6bd3f9c5b6d9d0405c8eb9313c389"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="omp_8h.html#a61a6bd3f9c5b6d9d0405c8eb9313c389">omp_get_thread_limit</a> (void)</td></tr>
<tr class="memdesc:a61a6bd3f9c5b6d9d0405c8eb9313c389"><td class="mdescLeft">&#160;</td><td class="mdescRight">obtains he maximum number of OpenMP threads available  <a href="#a61a6bd3f9c5b6d9d0405c8eb9313c389">More...</a><br /></td></tr>
<tr class="separator:a61a6bd3f9c5b6d9d0405c8eb9313c389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0faee69a9f06173aa7f63c1f05c6332"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="omp_8h.html#af0faee69a9f06173aa7f63c1f05c6332">omp_set_max_active_levels</a> (int max_active_levels)</td></tr>
<tr class="memdesc:af0faee69a9f06173aa7f63c1f05c6332"><td class="mdescLeft">&#160;</td><td class="mdescRight">limits the nested depth  <a href="#af0faee69a9f06173aa7f63c1f05c6332">More...</a><br /></td></tr>
<tr class="separator:af0faee69a9f06173aa7f63c1f05c6332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a231d4e774203f4812e97918ead79791b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="omp_8h.html#a231d4e774203f4812e97918ead79791b">omp_get_max_active_levels</a> (void)</td></tr>
<tr class="memdesc:a231d4e774203f4812e97918ead79791b"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the maximim nested depth  <a href="#a231d4e774203f4812e97918ead79791b">More...</a><br /></td></tr>
<tr class="separator:a231d4e774203f4812e97918ead79791b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c50b90416dbb06d3932d628a0e7dac5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="omp_8h.html#a9c50b90416dbb06d3932d628a0e7dac5">omp_get_level</a> (void)</td></tr>
<tr class="memdesc:a9c50b90416dbb06d3932d628a0e7dac5"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the level the task is runnig at  <a href="#a9c50b90416dbb06d3932d628a0e7dac5">More...</a><br /></td></tr>
<tr class="separator:a9c50b90416dbb06d3932d628a0e7dac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2928b23e3d8d0cdd5d9eb6953de44b4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="omp_8h.html#aa2928b23e3d8d0cdd5d9eb6953de44b4">omp_get_ancestor_thread_num</a> (int level)</td></tr>
<tr class="memdesc:aa2928b23e3d8d0cdd5d9eb6953de44b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the ancestor thread number of a thread at a given level  <a href="#aa2928b23e3d8d0cdd5d9eb6953de44b4">More...</a><br /></td></tr>
<tr class="separator:aa2928b23e3d8d0cdd5d9eb6953de44b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d4c2a2b2bcc53bf180780373e0ec02c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="omp_8h.html#a4d4c2a2b2bcc53bf180780373e0ec02c">omp_get_team_size</a> (int level)</td></tr>
<tr class="memdesc:a4d4c2a2b2bcc53bf180780373e0ec02c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the team size of a thread at a given level  <a href="#a4d4c2a2b2bcc53bf180780373e0ec02c">More...</a><br /></td></tr>
<tr class="separator:a4d4c2a2b2bcc53bf180780373e0ec02c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac10cbcb5a717dc3d03aaf80bc844f4aa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="omp_8h.html#ac10cbcb5a717dc3d03aaf80bc844f4aa">omp_get_active_level</a> (void)</td></tr>
<tr class="memdesc:ac10cbcb5a717dc3d03aaf80bc844f4aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the number of active, nested parallel regions  <a href="#ac10cbcb5a717dc3d03aaf80bc844f4aa">More...</a><br /></td></tr>
<tr class="separator:ac10cbcb5a717dc3d03aaf80bc844f4aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeea0890d6d9b6da78d93180bb42947ed"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="omp_8h.html#aeea0890d6d9b6da78d93180bb42947ed">omp_in_final</a> (void)</td></tr>
<tr class="memdesc:aeea0890d6d9b6da78d93180bb42947ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks if thread is in the final task region  <a href="#aeea0890d6d9b6da78d93180bb42947ed">More...</a><br /></td></tr>
<tr class="separator:aeea0890d6d9b6da78d93180bb42947ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7aaef18c634aa145dc61603001d9857"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="omp_8h.html#ad7aaef18c634aa145dc61603001d9857">omp_init_lock</a> (<a class="el" href="struct____omp__lock.html">omp_lock_t</a> *lock)</td></tr>
<tr class="memdesc:ad7aaef18c634aa145dc61603001d9857"><td class="mdescLeft">&#160;</td><td class="mdescRight">initializes and allocates a simple OpenMP lock  <a href="#ad7aaef18c634aa145dc61603001d9857">More...</a><br /></td></tr>
<tr class="separator:ad7aaef18c634aa145dc61603001d9857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae19114f8c7129ec37e6223898e9e4b27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="omp_8h.html#ae19114f8c7129ec37e6223898e9e4b27">omp_destroy_lock</a> (<a class="el" href="struct____omp__lock.html">omp_lock_t</a> *lock)</td></tr>
<tr class="memdesc:ae19114f8c7129ec37e6223898e9e4b27"><td class="mdescLeft">&#160;</td><td class="mdescRight">destroys a simple OpenMP lock  <a href="#ae19114f8c7129ec37e6223898e9e4b27">More...</a><br /></td></tr>
<tr class="separator:ae19114f8c7129ec37e6223898e9e4b27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f5b90eefa752f326e748ab61cfe2591"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="omp_8h.html#a8f5b90eefa752f326e748ab61cfe2591">omp_set_lock</a> (<a class="el" href="struct____omp__lock.html">omp_lock_t</a> *lock)</td></tr>
<tr class="memdesc:a8f5b90eefa752f326e748ab61cfe2591"><td class="mdescLeft">&#160;</td><td class="mdescRight">acquires a simple OpenMP lock  <a href="#a8f5b90eefa752f326e748ab61cfe2591">More...</a><br /></td></tr>
<tr class="separator:a8f5b90eefa752f326e748ab61cfe2591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e91fc1ebaec18150a9cf93c8f76b1d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="omp_8h.html#a0e91fc1ebaec18150a9cf93c8f76b1d7">omp_unset_lock</a> (<a class="el" href="struct____omp__lock.html">omp_lock_t</a> *lock)</td></tr>
<tr class="memdesc:a0e91fc1ebaec18150a9cf93c8f76b1d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the simple OpenMP lock.  <a href="#a0e91fc1ebaec18150a9cf93c8f76b1d7">More...</a><br /></td></tr>
<tr class="separator:a0e91fc1ebaec18150a9cf93c8f76b1d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9d116197be3f660300475e5b70b1324"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="omp_8h.html#aa9d116197be3f660300475e5b70b1324">omp_test_lock</a> (<a class="el" href="struct____omp__lock.html">omp_lock_t</a> *lock)</td></tr>
<tr class="memdesc:aa9d116197be3f660300475e5b70b1324"><td class="mdescLeft">&#160;</td><td class="mdescRight">tries to acquire a simple openMP lock  <a href="#aa9d116197be3f660300475e5b70b1324">More...</a><br /></td></tr>
<tr class="separator:aa9d116197be3f660300475e5b70b1324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d93e62dbefc74abc41213ede52d0ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="omp_8h.html#ad8d93e62dbefc74abc41213ede52d0ee">omp_init_nest_lock</a> (omp_nest_lock_t *lock)</td></tr>
<tr class="memdesc:ad8d93e62dbefc74abc41213ede52d0ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">initializes and allocates a nested OpenMP lock  <a href="#ad8d93e62dbefc74abc41213ede52d0ee">More...</a><br /></td></tr>
<tr class="separator:ad8d93e62dbefc74abc41213ede52d0ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7668e9211db5f6e979706ca924a17e0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="omp_8h.html#a7668e9211db5f6e979706ca924a17e0f">omp_destroy_nest_lock</a> (omp_nest_lock_t *lock)</td></tr>
<tr class="memdesc:a7668e9211db5f6e979706ca924a17e0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">destroys a Nested OpenMP lock  <a href="#a7668e9211db5f6e979706ca924a17e0f">More...</a><br /></td></tr>
<tr class="separator:a7668e9211db5f6e979706ca924a17e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa18f9aa73703b179a3b23986bddd0027"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="omp_8h.html#aa18f9aa73703b179a3b23986bddd0027">omp_set_nest_lock</a> (omp_nest_lock_t *lock)</td></tr>
<tr class="memdesc:aa18f9aa73703b179a3b23986bddd0027"><td class="mdescLeft">&#160;</td><td class="mdescRight">acquires a simple OpenMP lock  <a href="#aa18f9aa73703b179a3b23986bddd0027">More...</a><br /></td></tr>
<tr class="separator:aa18f9aa73703b179a3b23986bddd0027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfebcf86479d62feee000a95f8838341"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="omp_8h.html#abfebcf86479d62feee000a95f8838341">omp_unset_nest_lock</a> (omp_nest_lock_t *lock)</td></tr>
<tr class="memdesc:abfebcf86479d62feee000a95f8838341"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the simple OpenMP lock.  <a href="#abfebcf86479d62feee000a95f8838341">More...</a><br /></td></tr>
<tr class="separator:abfebcf86479d62feee000a95f8838341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aa783de4d24047b1c883a1166cc43c9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="omp_8h.html#a9aa783de4d24047b1c883a1166cc43c9">omp_test_nest_lock</a> (omp_nest_lock_t *lock)</td></tr>
<tr class="memdesc:a9aa783de4d24047b1c883a1166cc43c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">tries to acquire a simple openMP lock  <a href="#a9aa783de4d24047b1c883a1166cc43c9">More...</a><br /></td></tr>
<tr class="separator:a9aa783de4d24047b1c883a1166cc43c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa02ecdff3ea7c347fec7a7f269d8428c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="omp_8h.html#aa02ecdff3ea7c347fec7a7f269d8428c">omp_get_wtime</a> (void)</td></tr>
<tr class="memdesc:aa02ecdff3ea7c347fec7a7f269d8428c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns elapsed wall clock time in seconds.  <a href="#aa02ecdff3ea7c347fec7a7f269d8428c">More...</a><br /></td></tr>
<tr class="separator:aa02ecdff3ea7c347fec7a7f269d8428c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b93b0e4775add58ed5e29b8f29ea2af"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="omp_8h.html#a4b93b0e4775add58ed5e29b8f29ea2af">omp_get_wtick</a> (void)</td></tr>
<tr class="memdesc:a4b93b0e4775add58ed5e29b8f29ea2af"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the precision of the timer used by omp_get_wtime.  <a href="#a4b93b0e4775add58ed5e29b8f29ea2af">More...</a><br /></td></tr>
<tr class="separator:a4b93b0e4775add58ed5e29b8f29ea2af"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Include to use the bomp library. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a1396d4ac5ba3b8fb5b92339e2ba97d7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OMP_VERSION_31&#160;&#160;&#160;0x0310</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>defines which OpenMP version is supported by the backend</p>
<p>OpenMP 4.0: 0x0400 OpenMP 3.1: 0x0310 </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ab7d4cb9bf8de53f6e23648e4f541a893"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="omp_8h.html#ab74053fd9c5f0b0d4136be24d7d55098">bomp_backend</a>  <a class="el" href="omp_8h.html#ab7d4cb9bf8de53f6e23648e4f541a893">bomp_backend_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>BOMP backend types </p>

</div>
</div>
<a class="anchor" id="a16bc19799524d5136341fa89b2662731"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="omp_8h.html#ab705b3379866fe5ef19518ef9185c06f">omp_sched</a>  <a class="el" href="omp_8h.html#a16bc19799524d5136341fa89b2662731">omp_sched_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>OpenMP schedule types </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ab74053fd9c5f0b0d4136be24d7d55098"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="omp_8h.html#ab74053fd9c5f0b0d4136be24d7d55098">bomp_backend</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>BOMP backend types </p>

</div>
</div>
<a class="anchor" id="ab705b3379866fe5ef19518ef9185c06f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="omp_8h.html#ab705b3379866fe5ef19518ef9185c06f">omp_sched</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>OpenMP schedule types </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a663cb7186ea9b0b88751fb571ddb9570"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="omp_8h.html#ab7d4cb9bf8de53f6e23648e4f541a893">bomp_backend_t</a> bomp_get_backend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>gets the currently enabled backend </p>
<dl class="section return"><dt>Returns</dt><dd>BOMP_BACKEND_*Default Stacksize for BOMP threads </dd></dl>

</div>
</div>
<a class="anchor" id="af43677538d4bbe4be9732b0fb7ed7f25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bomp_init_cores </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>coresbm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stack_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>initializes the BOMP library using the indicated cores of the BM </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coresbm</td><td>bitmap representing the cores to run on </td></tr>
    <tr><td class="paramname">stack_size</td><td>size of the thread's stack in bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on SUCCESS non-zero on FAILURE </dd></dl>

</div>
</div>
<a class="anchor" id="af9f7ac801da9b75e7f49e5a2b28e8c84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bomp_init_varstack </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nthreads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stack_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>initializes the BOMP library with the given stack sizes </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stack_size</td><td>size of the thread's stack in bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on SUCCESS non-zero on FAILURE</dd></dl>
<p>This function will use the first nthreads cores to run on </p>
<p>get the maximum number of cores </p>

</div>
</div>
<a class="anchor" id="ac7a88583c6bdea6764c51982239b35c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bomp_switch_backend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="omp_8h.html#ab7d4cb9bf8de53f6e23648e4f541a893">bomp_backend_t</a>&#160;</td>
          <td class="paramname"><em>backend</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>switches the backend to be used </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">backend</td><td>Backend to activate</td></tr>
  </table>
  </dd>
</dl>
<p>XXX: this has only to be used if XOMP and BOMP are used in the same library </p>

</div>
</div>
<a class="anchor" id="ae19114f8c7129ec37e6223898e9e4b27"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void omp_destroy_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct____omp__lock.html">omp_lock_t</a> *&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>destroys a simple OpenMP lock </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>OpenMP lock to destroyed (set to zero)</td></tr>
  </table>
  </dd>
</dl>
<p>The effect of these routines is to change the state of the lock to uninitialized. </p>

</div>
</div>
<a class="anchor" id="a7668e9211db5f6e979706ca924a17e0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void omp_destroy_nest_lock </td>
          <td>(</td>
          <td class="paramtype">omp_nest_lock_t *&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>destroys a Nested OpenMP lock </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>OpenMP lock to destroyed (set to zero)</td></tr>
  </table>
  </dd>
</dl>
<p>The effect of these routines is to change the state of the lock to uninitialized. </p>

</div>
</div>
<a class="anchor" id="ac10cbcb5a717dc3d03aaf80bc844f4aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int omp_get_active_level </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the number of active, nested parallel regions </p>
<dl class="section return"><dt>Returns</dt><dd>number of nested parallel regions *</dd></dl>
<p>The effect of the omp_get_active_level routine is to return the number of nested, active parallel regions enclosing the current task such that all of the parallel regions are enclosed by the outermost initial task region on the current device. </p>

</div>
</div>
<a class="anchor" id="aa2928b23e3d8d0cdd5d9eb6953de44b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int omp_get_ancestor_thread_num </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the ancestor thread number of a thread at a given level </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>the level of the ancestor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>thread number of ancestor thread</dd></dl>
<p>The omp_get_ancestor_thread_num routine returns the thread number of the ancestor at a given nest level of the current thread or the thread number of the current thread. If the requested nest level is outside the range of 0 and the nest level of the current thread, as returned by the omp_get_level routine, the routine returns -1. </p>

</div>
</div>
<a class="anchor" id="af6a3613a1eb4247a2f419c194df7f5df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int omp_get_dynamic </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>checks if the dynamic behavior is enabled for the current task </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if dynamic behavior enabled FALSE if disabled</dd></dl>
<p>This routine returns the value of the dyn-var ICV, which is true if dynamic adjustment of the number of threads is enabled for the current task. </p>

</div>
</div>
<a class="anchor" id="a9c50b90416dbb06d3932d628a0e7dac5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int omp_get_level </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the level the task is runnig at </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">number</td><td>enclosing nested parallel regions</td></tr>
  </table>
  </dd>
</dl>
<p>For the enclosing device region, returns the levels-vars ICV, which is the number of nested parallel regions that enclose the task containing the call. </p>

</div>
</div>
<a class="anchor" id="a231d4e774203f4812e97918ead79791b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int omp_get_max_active_levels </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the maximim nested depth </p>
<dl class="section return"><dt>Returns</dt><dd>maximum nested level</dd></dl>
<p>Returns the value of max-active-levels-var ICV, which determines the maximum number of nested active parallel regions. </p>

</div>
</div>
<a class="anchor" id="aa00d2b875207d14eba24b62e65e795dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int omp_get_max_threads </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the maximum number of threads that can be used for a new parallel task </p>
<dl class="section return"><dt>Returns</dt><dd>number of usable threads</dd></dl>
<p>Returns an upper bound on the number of threads that could be used to form a new team if a parallel construct without a num_threads clause were encountered after execution returns from this routine.</p>
<p>The value returned by omp_get_max_threads is the value of the first element of the nthreads-var ICV of the current task. This value is also an upper bound on the number of threads that could be used to form a new team if a parallel region without a num_threads clause were encountered after execution returns from this routine. </p>

</div>
</div>
<a class="anchor" id="a1ac016a437ca14b410b4acf04af76257"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int omp_get_nested </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>checks if the nested behavior is enabled </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if nested behavior is enabled FALSE if disabled</dd></dl>
<p>Returns the value of the nest-var ICV, which indicates if nested parallelism is enabled or disabled. </p>

</div>
</div>
<a class="anchor" id="a669d6cb8c2e92e8b13df20e9c089f730"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int omp_get_num_procs </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the number of available processors </p>
<dl class="section return"><dt>Returns</dt><dd>available processor count</dd></dl>
<p>Returns the number of processors that are available to the device at the time the routine is called. </p>

</div>
</div>
<a class="anchor" id="a9ed0474735f00e49f9e37e8c76e935e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int omp_get_num_threads </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the current number of threads used (innermost parallel region) </p>
<dl class="section return"><dt>Returns</dt><dd>number of used threads</dd></dl>
<p>Returns the number of threads in the current team. The binding region for an omp_get_num_threads region is the innermost enclosing parallel region. If called from the sequential part of a program, this routine returns 1. </p>
<p>if we are nested return 1 </p>

</div>
</div>
<a class="anchor" id="a2fd28034805870f3d3ed56822640e44a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void omp_get_schedule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="omp_8h.html#a16bc19799524d5136341fa89b2662731">omp_sched_t</a> *&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>modifier</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the current scheduler settings </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kind</td><td>returns the current scheduler setting (one of OMP_SCHED_*) </td></tr>
    <tr><td class="paramname">modifier</td><td>returns the modifier of the scheduler</td></tr>
  </table>
  </dd>
</dl>
<p>Returns the value of run-sched-var ICV, which is the schedule applied when runtime schedule is used. </p>

</div>
</div>
<a class="anchor" id="a4d4c2a2b2bcc53bf180780373e0ec02c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int omp_get_team_size </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the team size of a thread at a given level </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>the level to consider</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of threads in the team *</dd></dl>
<p>The omp_get_team_size routine returns the size of the thread team to which the ancestor or the current thread belongs. If the requested nested level is outside the range of 0 and the nested level of the current thread, as returned by the omp_get_level routine, the routine returns -1. Inactive parallel regions are regarded like active parallel regions executed with one thread. </p>

</div>
</div>
<a class="anchor" id="a61a6bd3f9c5b6d9d0405c8eb9313c389"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int omp_get_thread_limit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>obtains he maximum number of OpenMP threads available </p>
<dl class="section return"><dt>Returns</dt><dd>number of available threads</dd></dl>
<p>Returns the value of the thread-limit-var ICV, which is the maximum number of OpenMP threads available.</p>
<p>The binding thread set for an omp_get_thread_limit region is all threads on the device. The effect of executing this routine is not related to any specific region corresponding to any construct or API routine. </p>

</div>
</div>
<a class="anchor" id="afd4d1cfdcccf111a8ab472b1fef44d7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int omp_get_thread_num </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the thread number of the calling thread within the current team. </p>
<dl class="section return"><dt>Returns</dt><dd>ThreadID </dd></dl>

</div>
</div>
<a class="anchor" id="a4b93b0e4775add58ed5e29b8f29ea2af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double omp_get_wtick </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the precision of the timer used by omp_get_wtime. </p>
<dl class="section return"><dt>Returns</dt><dd>the timer precision</dd></dl>
<p>The omp_get_wtick routine returns a value equal to the number of seconds between successive clock ticks of the timer used by omp_get_wtime. </p>

</div>
</div>
<a class="anchor" id="aa02ecdff3ea7c347fec7a7f269d8428c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double omp_get_wtime </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns elapsed wall clock time in seconds. </p>
<dl class="section return"><dt>Returns</dt><dd>call clock time</dd></dl>
<p>The omp_get_wtime routine returns a value equal to the elapsed wall clock time in seconds since some “time in the past”. The actual “time in the past” is arbitrary, but it is guaranteed not to change during the execution of the application program. The time returned is a “per-thread time”, so it is not required to be globally consistent across all the threads participating in an application. </p>

</div>
</div>
<a class="anchor" id="aeea0890d6d9b6da78d93180bb42947ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int omp_in_final </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>checks if thread is in the final task region </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if thread is in the final task region FALSE otherwise</dd></dl>
<p>Returns true if the routine is executed in a final task region; otherwise, it returns false. </p>

</div>
</div>
<a class="anchor" id="afc9d0c25c3e17b17c0b5c53d87f0d36d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int omp_in_parallel </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>checks if we are currently in a parallel region </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE active threads is greater than 1 FALSE active threads is 1 (main thread)</dd></dl>
<p>Returns true if the active-levels-var ICV is greater than zero; otherwise it returns false. The effect of the omp_in_parallel routine is to return true if the current task is enclosed by an active parallel region, and the parallel region is enclosed by the outermost initial task region on the device; otherwise it returns false. </p>

</div>
</div>
<a class="anchor" id="ad7aaef18c634aa145dc61603001d9857"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void omp_init_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct____omp__lock.html">omp_lock_t</a> *&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>initializes and allocates a simple OpenMP lock </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>returned pointer to the lock</td></tr>
  </table>
  </dd>
</dl>
<p>The effect of these routines is to initialize the lock to the unlocked state; that is, no task owns the lock. </p>

</div>
</div>
<a class="anchor" id="ad8d93e62dbefc74abc41213ede52d0ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void omp_init_nest_lock </td>
          <td>(</td>
          <td class="paramtype">omp_nest_lock_t *&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>initializes and allocates a nested OpenMP lock </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>returned pointer to the lock</td></tr>
  </table>
  </dd>
</dl>
<p>The effect of these routines is to initialize the lock to the unlocked state; that is, no task owns the lock. In addition, the nesting count for a nestable lock is set to zero. </p>

</div>
</div>
<a class="anchor" id="ab681c69825d871dadd372aed316919ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void omp_set_dynamic </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dynamic_threads</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>enables / disables the dynamic behavior </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dynamic_threads</td><td>zero to disable dynamic behavior non-zero to enable dynamic behavior</td></tr>
  </table>
  </dd>
</dl>
<p>Returns the value of the dyn-var ICV, which indicates if dynamic adjustment of the number of threads is enabled or disabled. </p>

</div>
</div>
<a class="anchor" id="a8f5b90eefa752f326e748ab61cfe2591"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void omp_set_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct____omp__lock.html">omp_lock_t</a> *&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>acquires a simple OpenMP lock </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>The lock to acquire</td></tr>
  </table>
  </dd>
</dl>
<p>Each of these routines causes suspension of the task executing the routine until the specified lock is available and then sets the lock. </p>

</div>
</div>
<a class="anchor" id="af0faee69a9f06173aa7f63c1f05c6332"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void omp_set_max_active_levels </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_active_levels</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>limits the nested depth </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_active_levels</td><td>maximum nested level</td></tr>
  </table>
  </dd>
</dl>
<p>Limits the number of nested active parallel regions, by setting max-active-levels-var ICV. </p>

</div>
</div>
<a class="anchor" id="aa18f9aa73703b179a3b23986bddd0027"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void omp_set_nest_lock </td>
          <td>(</td>
          <td class="paramtype">omp_nest_lock_t *&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>acquires a simple OpenMP lock </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>The lock to acquire</td></tr>
  </table>
  </dd>
</dl>
<p>Each of these routines causes suspension of the task executing the routine until the specified lock is available and then sets the lock.</p>
<p>A nestable lock is available if it is unlocked or if it is already owned by the task executing the routine. The task executing the routine is granted, or retains, ownership of the lock, and the nesting count for the lock is incremented. </p>

</div>
</div>
<a class="anchor" id="a371bb992a1b3b50415ba10614f52e1e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void omp_set_nested </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nested</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables or disables nested parallelism, by setting the nest-var ICV. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nested</td><td>TRUE: enable nested behavior FALSE: disable nested behavior </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab2a1aadbe72ac6b1f9aed9a2ef8e0044"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void omp_set_num_threads </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_threads</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the number of threads to be used for parallel regions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_threads</td><td>the number of threads</td></tr>
  </table>
  </dd>
</dl>
<p>Affects the number of threads used for subsequent parallel regions not specifying a num_threads clause, by setting the value of the first element of the nthreads-var ICV of the current task to num_threads. </p>

</div>
</div>
<a class="anchor" id="a8f122914c4e1c1a7a8e77fa711dec436"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void omp_set_schedule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="omp_8h.html#a16bc19799524d5136341fa89b2662731">omp_sched_t</a>&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>modifier</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sets the schedule to be used </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kind</td><td>which schedule to be used (one of OMP_SCHED_*) </td></tr>
    <tr><td class="paramname">modifier</td><td>modifier to tweak the scheduler (depends on kind)</td></tr>
  </table>
  </dd>
</dl>
<p>The omp_set_schedule routine affects the schedule that is applied when runtime is used as schedule kind, by setting the value of the run-sched-var ICV. </p>

</div>
</div>
<a class="anchor" id="aa9d116197be3f660300475e5b70b1324"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int omp_test_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct____omp__lock.html">omp_lock_t</a> *&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>tries to acquire a simple openMP lock </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>The OpenMP lock to acquire</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if lock is acquired successfully FALSE if lock is already held by other thread</dd></dl>
<p>These routines attempt to set a lock in the same manner as omp_set_lock and omp_set_nest_lock, except that they do not suspend execution of the task executing the routine. For a simple lock, the omp_test_lock routine returns true if the lock is successfully set; otherwise, it returns false. </p>

</div>
</div>
<a class="anchor" id="a9aa783de4d24047b1c883a1166cc43c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int omp_test_nest_lock </td>
          <td>(</td>
          <td class="paramtype">omp_nest_lock_t *&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>tries to acquire a simple openMP lock </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>The OpenMP lock to acquire</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if lock is acquired successfully FALSE if lock is already held by other thread</dd></dl>
<p>These routines attempt to set a lock in the same manner as omp_set_lock and omp_set_nest_lock, except that they do not suspend execution of the task executing the routine. For a nestable lock, the omp_test_nest_lock routine returns the new nesting count if the lock is successfully set; otherwise, it returns zero. </p>

</div>
</div>
<a class="anchor" id="a0e91fc1ebaec18150a9cf93c8f76b1d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void omp_unset_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct____omp__lock.html">omp_lock_t</a> *&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases the simple OpenMP lock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>The lock to be released</td></tr>
  </table>
  </dd>
</dl>
<p>For a simple lock, the omp_unset_lock routine causes the lock to become unlocked. </p>

</div>
</div>
<a class="anchor" id="abfebcf86479d62feee000a95f8838341"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void omp_unset_nest_lock </td>
          <td>(</td>
          <td class="paramtype">omp_nest_lock_t *&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases the simple OpenMP lock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>The lock to be released</td></tr>
  </table>
  </dd>
</dl>
<p>For a nestable lock, the omp_unset_nest_lock routine decrements the nesting count, and causes the lock to become unlocked if the resulting nesting count is zero. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
