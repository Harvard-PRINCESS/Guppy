<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Barrelfish: Multicore and Synchronization Support</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Barrelfish
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Multicore and Synchronization Support</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga5f7b9a0821d5b20e865c41d917aedd7a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__or1k__multicore.html#ga5f7b9a0821d5b20e865c41d917aedd7a">or1k_has_multicore_support</a> (void)</td></tr>
<tr class="separator:ga5f7b9a0821d5b20e865c41d917aedd7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7634cfa9fe0495644c2d092146282745"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__or1k__multicore.html#ga7634cfa9fe0495644c2d092146282745">or1k_coreid</a> (void)</td></tr>
<tr class="separator:ga7634cfa9fe0495644c2d092146282745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0b5066158a5dc7e360d84ed0eb32d8c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__or1k__multicore.html#gab0b5066158a5dc7e360d84ed0eb32d8c">or1k_numcores</a> (void)</td></tr>
<tr class="separator:gab0b5066158a5dc7e360d84ed0eb32d8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf35bdd237d24908c26831a25f118d28"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__or1k__multicore.html#gacf35bdd237d24908c26831a25f118d28">or1k_sync_ll</a> (void *address)</td></tr>
<tr class="separator:gacf35bdd237d24908c26831a25f118d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae87e9d912dfd1e1b6ee740d6ab24e091"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__or1k__multicore.html#gae87e9d912dfd1e1b6ee740d6ab24e091">or1k_sync_sc</a> (void *address, uint32_t value)</td></tr>
<tr class="separator:gae87e9d912dfd1e1b6ee740d6ab24e091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac87806fdafd0b1e65ad6c961fe6dba8e"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__or1k__multicore.html#gac87806fdafd0b1e65ad6c961fe6dba8e">or1k_sync_cas</a> (void *address, uint32_t compare, uint32_t swap)</td></tr>
<tr class="separator:gac87806fdafd0b1e65ad6c961fe6dba8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ae9688b954590e20e37381b303c661f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__or1k__multicore.html#ga5ae9688b954590e20e37381b303c661f">or1k_sync_tsl</a> (void *address)</td></tr>
<tr class="separator:ga5ae9688b954590e20e37381b303c661f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga7634cfa9fe0495644c2d092146282745"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t or1k_coreid </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read core identifier</p>
<dl class="section return"><dt>Returns</dt><dd>Core identifier </dd></dl>

</div>
</div>
<a class="anchor" id="ga5f7b9a0821d5b20e865c41d917aedd7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t or1k_has_multicore_support </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compiled with multicore support</p>
<dl class="section return"><dt>Returns</dt><dd>1 if compiled with multicore support, 0 otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="gab0b5066158a5dc7e360d84ed0eb32d8c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t or1k_numcores </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read number of cores</p>
<dl class="section return"><dt>Returns</dt><dd>Total number of cores </dd></dl>

</div>
</div>
<a class="anchor" id="gac87806fdafd0b1e65ad6c961fe6dba8e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t or1k_sync_cas </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>compare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>swap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compare and Swap</p>
<p>Loads a data item from the memory and compares a given value to it. If the values match, a new value is written to the memory, if they mismatch, the operation is aborted. The whole operation is atomic, i.e., it is guaranteed that no other core changes the value between the read and the write.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>Address to operate on </td></tr>
    <tr><td class="paramname">compare</td><td>Compare value </td></tr>
    <tr><td class="paramname">swap</td><td>New value to write </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value read from memory (can be used to check for success) </dd></dl>

</div>
</div>
<a class="anchor" id="gacf35bdd237d24908c26831a25f118d28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t or1k_sync_ll </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load linked</p>
<p>Load a value from the given address and link it. If the following <a class="el" href="group__or1k__multicore.html#gae87e9d912dfd1e1b6ee740d6ab24e091">or1k_sync_sc()</a> goes to the same address and there was no conflicting access between loading and storing, the value is written back, else the write fails.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>Address to load value from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value read from the address </dd></dl>

</div>
</div>
<a class="anchor" id="gae87e9d912dfd1e1b6ee740d6ab24e091"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int or1k_sync_sc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Store conditional</p>
<p>Conditionally store a value to the address. The address must have been read before using <a class="el" href="group__or1k__multicore.html#gacf35bdd237d24908c26831a25f118d28">or1k_sync_ll()</a> and there must be no other load link after that, otherwise this will always fail. In case there was no other write to the same address in between the load link and the store conditional, the store is successful, otherwise it will also fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>Address to conditionally store to </td></tr>
    <tr><td class="paramname">value</td><td>Value to write to address </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if success, 0 if fail </dd></dl>

</div>
</div>
<a class="anchor" id="ga5ae9688b954590e20e37381b303c661f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int or1k_sync_tsl </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test and Set Lock</p>
<p>Check for a lock on an address. This means, if there is 0 at an address it will overwrite it with 1 and return 0. If the lock was already set (value 1 read from address), the function returns 1. The operation is atomic.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>Address of the lock </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, 1 if failed </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
