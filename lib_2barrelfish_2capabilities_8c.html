<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Barrelfish: lib/barrelfish/capabilities.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Barrelfish
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_fb59824686554dca48bb2d83e9c24bc6.html">barrelfish</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">capabilities.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Capability system user code.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ac9ff7b0829e2f85550e9301ee4750b76"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac9ff7b0829e2f85550e9301ee4750b76"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lib_2barrelfish_2capabilities_8c.html#ac9ff7b0829e2f85550e9301ee4750b76">ROOT_CNODE_INIT</a></td></tr>
<tr class="memdesc:ac9ff7b0829e2f85550e9301ee4750b76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Root CNode. <br /></td></tr>
<tr class="separator:ac9ff7b0829e2f85550e9301ee4750b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:affa248fd38ad2e189d57f8c842e1a60e"><td class="memItemLeft" align="right" valign="top">errval_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lib_2barrelfish_2capabilities_8c.html#affa248fd38ad2e189d57f8c842e1a60e">cap_retype</a> (struct <a class="el" href="structcapref.html">capref</a> dest_start, struct <a class="el" href="structcapref.html">capref</a> src, gensize_t offset, enum objtype new_type, gensize_t objsize, size_t count)</td></tr>
<tr class="memdesc:affa248fd38ad2e189d57f8c842e1a60e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retype (part of) a capability into one or more new capabilities.  <a href="#affa248fd38ad2e189d57f8c842e1a60e">More...</a><br /></td></tr>
<tr class="separator:affa248fd38ad2e189d57f8c842e1a60e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2106e8cc8fb701dd3b775e50aad06927"><td class="memItemLeft" align="right" valign="top">errval_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lib_2barrelfish_2capabilities_8c.html#a2106e8cc8fb701dd3b775e50aad06927">cap_create</a> (struct <a class="el" href="structcapref.html">capref</a> dest, enum objtype type, size_t size)</td></tr>
<tr class="memdesc:a2106e8cc8fb701dd3b775e50aad06927"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a capability.  <a href="#a2106e8cc8fb701dd3b775e50aad06927">More...</a><br /></td></tr>
<tr class="separator:a2106e8cc8fb701dd3b775e50aad06927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a869c261bec2ea52460bb6a27dfeb17e4"><td class="memItemLeft" align="right" valign="top">errval_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lib_2barrelfish_2capabilities_8c.html#a869c261bec2ea52460bb6a27dfeb17e4">cap_delete</a> (struct <a class="el" href="structcapref.html">capref</a> cap)</td></tr>
<tr class="memdesc:a869c261bec2ea52460bb6a27dfeb17e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the given capability.  <a href="#a869c261bec2ea52460bb6a27dfeb17e4">More...</a><br /></td></tr>
<tr class="separator:a869c261bec2ea52460bb6a27dfeb17e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3a057363c859fd79d360bf35cb57879"><td class="memItemLeft" align="right" valign="top">errval_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lib_2barrelfish_2capabilities_8c.html#ad3a057363c859fd79d360bf35cb57879">cap_revoke</a> (struct <a class="el" href="structcapref.html">capref</a> cap)</td></tr>
<tr class="memdesc:ad3a057363c859fd79d360bf35cb57879"><td class="mdescLeft">&#160;</td><td class="mdescRight">Revoke (delete all copies and descendants of) the given capability.  <a href="#ad3a057363c859fd79d360bf35cb57879">More...</a><br /></td></tr>
<tr class="separator:ad3a057363c859fd79d360bf35cb57879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5457f9c30fec400262de48939f2e2b5"><td class="memItemLeft" align="right" valign="top">errval_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lib_2barrelfish_2capabilities_8c.html#ab5457f9c30fec400262de48939f2e2b5">cap_destroy</a> (struct <a class="el" href="structcapref.html">capref</a> cap)</td></tr>
<tr class="memdesc:ab5457f9c30fec400262de48939f2e2b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a capability, i.e. delete it and free the slot.  <a href="#ab5457f9c30fec400262de48939f2e2b5">More...</a><br /></td></tr>
<tr class="separator:ab5457f9c30fec400262de48939f2e2b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdbebea930c218583af41b83ab28020f"><td class="memItemLeft" align="right" valign="top">errval_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lib_2barrelfish_2capabilities_8c.html#acdbebea930c218583af41b83ab28020f">root_cnode_resize</a> (struct <a class="el" href="structcapref.html">capref</a> new, struct <a class="el" href="structcapref.html">capref</a> ret)</td></tr>
<tr class="memdesc:acdbebea930c218583af41b83ab28020f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace own L1 CNode.  <a href="#acdbebea930c218583af41b83ab28020f">More...</a><br /></td></tr>
<tr class="separator:acdbebea930c218583af41b83ab28020f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a119d05e40d9461cc43b39f8e085379ac"><td class="memItemLeft" align="right" valign="top">errval_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lib_2barrelfish_2capabilities_8c.html#a119d05e40d9461cc43b39f8e085379ac">cnode_create_from_mem</a> (struct <a class="el" href="structcapref.html">capref</a> dest, struct <a class="el" href="structcapref.html">capref</a> src, enum objtype cntype, struct <a class="el" href="structcnoderef.html">cnoderef</a> *<a class="el" href="structcnoderef.html">cnoderef</a>, size_t slots)</td></tr>
<tr class="memdesc:a119d05e40d9461cc43b39f8e085379ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a CNode from a given RAM capability in a specific slot.  <a href="#a119d05e40d9461cc43b39f8e085379ac">More...</a><br /></td></tr>
<tr class="separator:a119d05e40d9461cc43b39f8e085379ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c747ee463085fcd5cf3ff13afa91f3f"><td class="memItemLeft" align="right" valign="top">errval_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lib_2barrelfish_2capabilities_8c.html#a4c747ee463085fcd5cf3ff13afa91f3f">cnode_create</a> (struct <a class="el" href="structcapref.html">capref</a> *ret_dest, struct <a class="el" href="structcnoderef.html">cnoderef</a> *<a class="el" href="structcnoderef.html">cnoderef</a>, cslot_t slots, cslot_t *retslots)</td></tr>
<tr class="memdesc:a4c747ee463085fcd5cf3ff13afa91f3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a CNode from newly-allocated RAM in a newly-allocated slot.  <a href="#a4c747ee463085fcd5cf3ff13afa91f3f">More...</a><br /></td></tr>
<tr class="separator:a4c747ee463085fcd5cf3ff13afa91f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd7ed7dc87bb7ee598baea3f3eca141"><td class="memItemLeft" align="right" valign="top">errval_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lib_2barrelfish_2capabilities_8c.html#a4bd7ed7dc87bb7ee598baea3f3eca141">cnode_create_l2</a> (struct <a class="el" href="structcapref.html">capref</a> *ret_dest, struct <a class="el" href="structcnoderef.html">cnoderef</a> *<a class="el" href="structcnoderef.html">cnoderef</a>)</td></tr>
<tr class="memdesc:a4bd7ed7dc87bb7ee598baea3f3eca141"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a L2 CNode from newly-allocated RAM in a newly-allocated slot.  <a href="#a4bd7ed7dc87bb7ee598baea3f3eca141">More...</a><br /></td></tr>
<tr class="separator:a4bd7ed7dc87bb7ee598baea3f3eca141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add3751fbddb2bfca91f43cc21053463a"><td class="memItemLeft" align="right" valign="top">errval_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lib_2barrelfish_2capabilities_8c.html#add3751fbddb2bfca91f43cc21053463a">cnode_create_foreign_l2</a> (struct <a class="el" href="structcapref.html">capref</a> dest_l1, cslot_t dest_slot, struct <a class="el" href="structcnoderef.html">cnoderef</a> *<a class="el" href="structcnoderef.html">cnoderef</a>)</td></tr>
<tr class="memdesc:add3751fbddb2bfca91f43cc21053463a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a CNode for another cspace from newly-allocated RAM in a newly-allocated slot.  <a href="#add3751fbddb2bfca91f43cc21053463a">More...</a><br /></td></tr>
<tr class="separator:add3751fbddb2bfca91f43cc21053463a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e1ed82615c06db3257d588d37e13e1f"><td class="memItemLeft" align="right" valign="top">errval_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lib_2barrelfish_2capabilities_8c.html#a8e1ed82615c06db3257d588d37e13e1f">cnode_create_raw</a> (struct <a class="el" href="structcapref.html">capref</a> dest, struct <a class="el" href="structcnoderef.html">cnoderef</a> *<a class="el" href="structcnoderef.html">cnoderef</a>, enum objtype cntype, cslot_t slots, cslot_t *retslots)</td></tr>
<tr class="memdesc:a8e1ed82615c06db3257d588d37e13e1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a CNode from newly-allocated RAM in the given slot.  <a href="#a8e1ed82615c06db3257d588d37e13e1f">More...</a><br /></td></tr>
<tr class="separator:a8e1ed82615c06db3257d588d37e13e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada98fd333297149570bf76792b99a1a6"><td class="memItemLeft" align="right" valign="top">errval_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lib_2barrelfish_2capabilities_8c.html#ada98fd333297149570bf76792b99a1a6">cnode_create_with_guard</a> (struct <a class="el" href="structcapref.html">capref</a> dest, struct <a class="el" href="structcnoderef.html">cnoderef</a> *<a class="el" href="structcnoderef.html">cnoderef</a>, cslot_t slots, cslot_t *retslots, uint64_t guard, uint8_t guard_size)</td></tr>
<tr class="memdesc:ada98fd333297149570bf76792b99a1a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create CNode with a given guard.  <a href="#ada98fd333297149570bf76792b99a1a6">More...</a><br /></td></tr>
<tr class="separator:ada98fd333297149570bf76792b99a1a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a859d10247c776dea4bdf9df96a00c4a3"><td class="memItemLeft" align="right" valign="top">errval_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lib_2barrelfish_2capabilities_8c.html#a859d10247c776dea4bdf9df96a00c4a3">vnode_create</a> (struct <a class="el" href="structcapref.html">capref</a> dest, enum objtype type)</td></tr>
<tr class="memdesc:a859d10247c776dea4bdf9df96a00c4a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a VNode in newly-allocated memory.  <a href="#a859d10247c776dea4bdf9df96a00c4a3">More...</a><br /></td></tr>
<tr class="separator:a859d10247c776dea4bdf9df96a00c4a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afec3c6ac9e37d96b8daa32d2ce7ed69f"><td class="memItemLeft" align="right" valign="top">errval_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lib_2barrelfish_2capabilities_8c.html#afec3c6ac9e37d96b8daa32d2ce7ed69f">frame_create</a> (struct <a class="el" href="structcapref.html">capref</a> dest, size_t bytes, size_t *retbytes)</td></tr>
<tr class="memdesc:afec3c6ac9e37d96b8daa32d2ce7ed69f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a Frame cap referring to newly-allocated RAM in a given slot.  <a href="#afec3c6ac9e37d96b8daa32d2ce7ed69f">More...</a><br /></td></tr>
<tr class="separator:afec3c6ac9e37d96b8daa32d2ce7ed69f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a10f4dff0fd4d61e12735ffc0e029e6"><td class="memItemLeft" align="right" valign="top">errval_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lib_2barrelfish_2capabilities_8c.html#a1a10f4dff0fd4d61e12735ffc0e029e6">dispatcher_create</a> (struct <a class="el" href="structcapref.html">capref</a> dest)</td></tr>
<tr class="memdesc:a1a10f4dff0fd4d61e12735ffc0e029e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a Dispatcher in newly-allocated memory.  <a href="#a1a10f4dff0fd4d61e12735ffc0e029e6">More...</a><br /></td></tr>
<tr class="separator:a1a10f4dff0fd4d61e12735ffc0e029e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df05ed17aabaaa79e4728c31320ebd5"><td class="memItemLeft" align="right" valign="top">errval_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lib_2barrelfish_2capabilities_8c.html#a9df05ed17aabaaa79e4728c31320ebd5">endpoint_create</a> (size_t buflen, struct <a class="el" href="structcapref.html">capref</a> *retcap, struct <a class="el" href="structlmp__endpoint.html">lmp_endpoint</a> **retep)</td></tr>
<tr class="memdesc:a9df05ed17aabaaa79e4728c31320ebd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create endpoint to caller on current dispatcher.  <a href="#a9df05ed17aabaaa79e4728c31320ebd5">More...</a><br /></td></tr>
<tr class="separator:a9df05ed17aabaaa79e4728c31320ebd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae500f89147ca5e20ff4b7e846c027957"><td class="memItemLeft" align="right" valign="top">errval_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lib_2barrelfish_2capabilities_8c.html#ae500f89147ca5e20ff4b7e846c027957">frame_alloc</a> (struct <a class="el" href="structcapref.html">capref</a> *dest, size_t bytes, size_t *retbytes)</td></tr>
<tr class="memdesc:ae500f89147ca5e20ff4b7e846c027957"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a Frame cap referring to newly-allocated RAM in an allocated slot.  <a href="#ae500f89147ca5e20ff4b7e846c027957">More...</a><br /></td></tr>
<tr class="separator:ae500f89147ca5e20ff4b7e846c027957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c85327bee70a3ed0a5d045b9147b952"><td class="memItemLeft" align="right" valign="top">errval_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lib_2barrelfish_2capabilities_8c.html#a3c85327bee70a3ed0a5d045b9147b952">devframe_type</a> (struct <a class="el" href="structcapref.html">capref</a> *dest, struct <a class="el" href="structcapref.html">capref</a> src, uint8_t bits)</td></tr>
<tr class="memdesc:a3c85327bee70a3ed0a5d045b9147b952"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a DevFrame cap by retyping out of given source PhysAddr cap.  <a href="#a3c85327bee70a3ed0a5d045b9147b952">More...</a><br /></td></tr>
<tr class="separator:a3c85327bee70a3ed0a5d045b9147b952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa74c9d2e0e902dce8f6934a05685a70"><td class="memItemLeft" align="right" valign="top">errval_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lib_2barrelfish_2capabilities_8c.html#aaa74c9d2e0e902dce8f6934a05685a70">idcap_alloc</a> (struct <a class="el" href="structcapref.html">capref</a> *dest)</td></tr>
<tr class="memdesc:aaa74c9d2e0e902dce8f6934a05685a70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an ID cap in a newly allocated slot.  <a href="#aaa74c9d2e0e902dce8f6934a05685a70">More...</a><br /></td></tr>
<tr class="separator:aaa74c9d2e0e902dce8f6934a05685a70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec020ef8d626833e4dd0d77879ca0d8"><td class="memItemLeft" align="right" valign="top">errval_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lib_2barrelfish_2capabilities_8c.html#a4ec020ef8d626833e4dd0d77879ca0d8">idcap_create</a> (struct <a class="el" href="structcapref.html">capref</a> dest)</td></tr>
<tr class="memdesc:a4ec020ef8d626833e4dd0d77879ca0d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an ID cap in the specified slot.  <a href="#a4ec020ef8d626833e4dd0d77879ca0d8">More...</a><br /></td></tr>
<tr class="separator:a4ec020ef8d626833e4dd0d77879ca0d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b177f44fbb9477fde222d7c7b523c97"><td class="memItemLeft" align="right" valign="top">errval_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lib_2barrelfish_2capabilities_8c.html#a0b177f44fbb9477fde222d7c7b523c97">cnode_build_cnoderef</a> (struct <a class="el" href="structcnoderef.html">cnoderef</a> *cnoder, struct <a class="el" href="structcapref.html">capref</a> capr)</td></tr>
<tr class="memdesc:a0b177f44fbb9477fde222d7c7b523c97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a <a class="el" href="structcnoderef.html" title="User-level representation of a CNode, this is essentially a capref to a CNode. ">cnoderef</a> struct from a <a class="el" href="structcapref.html" title="User-level representation of a capability and its CSpace address. ">capref</a> struct using cap identification.  <a href="#a0b177f44fbb9477fde222d7c7b523c97">More...</a><br /></td></tr>
<tr class="separator:a0b177f44fbb9477fde222d7c7b523c97"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a8111681723865ade29e3464e72770143"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8111681723865ade29e3464e72770143"></a>
struct <a class="el" href="structcnoderef.html">cnoderef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lib_2barrelfish_2capabilities_8c.html#a8111681723865ade29e3464e72770143">cnode_task</a> = TASK_CNODE_INIT</td></tr>
<tr class="memdesc:a8111681723865ade29e3464e72770143"><td class="mdescLeft">&#160;</td><td class="mdescRight">Task CNode. <br /></td></tr>
<tr class="separator:a8111681723865ade29e3464e72770143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade67aced56da496b83cc236f7a8e0027"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade67aced56da496b83cc236f7a8e0027"></a>
struct <a class="el" href="structcnoderef.html">cnoderef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lib_2barrelfish_2capabilities_8c.html#ade67aced56da496b83cc236f7a8e0027">cnode_base</a></td></tr>
<tr class="memdesc:ade67aced56da496b83cc236f7a8e0027"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base CNode. <br /></td></tr>
<tr class="separator:ade67aced56da496b83cc236f7a8e0027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1263979e5d3742e992b598b4dc458faf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1263979e5d3742e992b598b4dc458faf"></a>
struct <a class="el" href="structcnoderef.html">cnoderef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lib_2barrelfish_2capabilities_8c.html#a1263979e5d3742e992b598b4dc458faf">cnode_super</a></td></tr>
<tr class="memdesc:a1263979e5d3742e992b598b4dc458faf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Super CNode. <br /></td></tr>
<tr class="separator:a1263979e5d3742e992b598b4dc458faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaab8269533bf76e8d1d7273350af46e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abaab8269533bf76e8d1d7273350af46e"></a>
struct <a class="el" href="structcnoderef.html">cnoderef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lib_2barrelfish_2capabilities_8c.html#abaab8269533bf76e8d1d7273350af46e">cnode_page</a> = PAGE_CNODE_INIT</td></tr>
<tr class="memdesc:abaab8269533bf76e8d1d7273350af46e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Page CNode. <br /></td></tr>
<tr class="separator:abaab8269533bf76e8d1d7273350af46e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb6b79253083c877b041b67282ae4702"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afb6b79253083c877b041b67282ae4702"></a>
struct <a class="el" href="structcnoderef.html">cnoderef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lib_2barrelfish_2capabilities_8c.html#afb6b79253083c877b041b67282ae4702">cnode_module</a></td></tr>
<tr class="memdesc:afb6b79253083c877b041b67282ae4702"><td class="mdescLeft">&#160;</td><td class="mdescRight">Module CNode. <br /></td></tr>
<tr class="separator:afb6b79253083c877b041b67282ae4702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ced033377aecddfa00cc7a1a5b1f165"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ced033377aecddfa00cc7a1a5b1f165"></a>
struct <a class="el" href="structcapref.html">capref</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lib_2barrelfish_2capabilities_8c.html#a9ced033377aecddfa00cc7a1a5b1f165">cap_root</a></td></tr>
<tr class="memdesc:a9ced033377aecddfa00cc7a1a5b1f165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Capability to Root CNode. <br /></td></tr>
<tr class="separator:a9ced033377aecddfa00cc7a1a5b1f165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f85f0ee8f632ff51ae51b7b62e49b41"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f85f0ee8f632ff51ae51b7b62e49b41"></a>
struct <a class="el" href="structcapref.html">capref</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lib_2barrelfish_2capabilities_8c.html#a3f85f0ee8f632ff51ae51b7b62e49b41">cap_irq</a></td></tr>
<tr class="memdesc:a3f85f0ee8f632ff51ae51b7b62e49b41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Capability for IRQ table. <br /></td></tr>
<tr class="separator:a3f85f0ee8f632ff51ae51b7b62e49b41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5420af6bb416c975ee16c949e67df434"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5420af6bb416c975ee16c949e67df434"></a>
struct <a class="el" href="structcapref.html">capref</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lib_2barrelfish_2capabilities_8c.html#a5420af6bb416c975ee16c949e67df434">cap_io</a></td></tr>
<tr class="memdesc:a5420af6bb416c975ee16c949e67df434"><td class="mdescLeft">&#160;</td><td class="mdescRight">Capability for legacy IO. <br /></td></tr>
<tr class="separator:a5420af6bb416c975ee16c949e67df434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc6f1954541a3acb3c578396d2f53a3d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc6f1954541a3acb3c578396d2f53a3d"></a>
struct <a class="el" href="structcapref.html">capref</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lib_2barrelfish_2capabilities_8c.html#adc6f1954541a3acb3c578396d2f53a3d">cap_selfep</a></td></tr>
<tr class="memdesc:adc6f1954541a3acb3c578396d2f53a3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Capability for endpoint to self. <br /></td></tr>
<tr class="separator:adc6f1954541a3acb3c578396d2f53a3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a349f2af728b06f8204d3b542db828759"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a349f2af728b06f8204d3b542db828759"></a>
struct <a class="el" href="structcapref.html">capref</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lib_2barrelfish_2capabilities_8c.html#a349f2af728b06f8204d3b542db828759">cap_dispatcher</a></td></tr>
<tr class="memdesc:a349f2af728b06f8204d3b542db828759"><td class="mdescLeft">&#160;</td><td class="mdescRight">Capability for dispatcher. <br /></td></tr>
<tr class="separator:a349f2af728b06f8204d3b542db828759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaed1f217ee8f73c073e9642565912d9f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaed1f217ee8f73c073e9642565912d9f"></a>
struct <a class="el" href="structcapref.html">capref</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lib_2barrelfish_2capabilities_8c.html#aaed1f217ee8f73c073e9642565912d9f">cap_dispframe</a></td></tr>
<tr class="memdesc:aaed1f217ee8f73c073e9642565912d9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Capability for dispatcher. <br /></td></tr>
<tr class="separator:aaed1f217ee8f73c073e9642565912d9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59d37453a7291a6ec10a86180156031c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a59d37453a7291a6ec10a86180156031c"></a>
struct <a class="el" href="structcapref.html">capref</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lib_2barrelfish_2capabilities_8c.html#a59d37453a7291a6ec10a86180156031c">cap_argcn</a></td></tr>
<tr class="memdesc:a59d37453a7291a6ec10a86180156031c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Capability for ArgSpace. <br /></td></tr>
<tr class="separator:a59d37453a7291a6ec10a86180156031c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdf0413352cefe437c3841ce7226bfad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afdf0413352cefe437c3841ce7226bfad"></a>
struct <a class="el" href="structcapref.html">capref</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lib_2barrelfish_2capabilities_8c.html#afdf0413352cefe437c3841ce7226bfad">cap_monitorep</a></td></tr>
<tr class="memdesc:afdf0413352cefe437c3841ce7226bfad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Capability for monitor endpoint. <br /></td></tr>
<tr class="separator:afdf0413352cefe437c3841ce7226bfad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83d62287e315d378bb17a9a84d70ab55"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a83d62287e315d378bb17a9a84d70ab55"></a>
struct <a class="el" href="structcapref.html">capref</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lib_2barrelfish_2capabilities_8c.html#a83d62287e315d378bb17a9a84d70ab55">cap_kernel</a></td></tr>
<tr class="memdesc:a83d62287e315d378bb17a9a84d70ab55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Capability for kernel (only in monitor) <br /></td></tr>
<tr class="separator:a83d62287e315d378bb17a9a84d70ab55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7f919abfea609428cca70e183c8480f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af7f919abfea609428cca70e183c8480f"></a>
struct <a class="el" href="structcapref.html">capref</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lib_2barrelfish_2capabilities_8c.html#af7f919abfea609428cca70e183c8480f">cap_ipi</a></td></tr>
<tr class="memdesc:af7f919abfea609428cca70e183c8480f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Capability for IPI sending (only in monitor) <br /></td></tr>
<tr class="separator:af7f919abfea609428cca70e183c8480f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a818a96b270a4985e3ec8209ebffcea54"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a818a96b270a4985e3ec8209ebffcea54"></a>
struct <a class="el" href="structcapref.html">capref</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lib_2barrelfish_2capabilities_8c.html#a818a96b270a4985e3ec8209ebffcea54">cap_perfmon</a></td></tr>
<tr class="memdesc:a818a96b270a4985e3ec8209ebffcea54"><td class="mdescLeft">&#160;</td><td class="mdescRight">PerfMon CNode. <br /></td></tr>
<tr class="separator:a818a96b270a4985e3ec8209ebffcea54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cae9f2c31b7478b4d05e41df0c26444"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6cae9f2c31b7478b4d05e41df0c26444"></a>
struct <a class="el" href="structcapref.html">capref</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lib_2barrelfish_2capabilities_8c.html#a6cae9f2c31b7478b4d05e41df0c26444">cap_initep</a></td></tr>
<tr class="memdesc:a6cae9f2c31b7478b4d05e41df0c26444"><td class="mdescLeft">&#160;</td><td class="mdescRight">Capability for endpoint to init (only in monitor/mem_serv) <br /></td></tr>
<tr class="separator:a6cae9f2c31b7478b4d05e41df0c26444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bd5ca7d97dd143d21671af74eff5bfe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9bd5ca7d97dd143d21671af74eff5bfe"></a>
struct <a class="el" href="structcapref.html">capref</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lib_2barrelfish_2capabilities_8c.html#a9bd5ca7d97dd143d21671af74eff5bfe">cap_sessionid</a></td></tr>
<tr class="memdesc:a9bd5ca7d97dd143d21671af74eff5bfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Session ID. <br /></td></tr>
<tr class="separator:a9bd5ca7d97dd143d21671af74eff5bfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dc7cee91cd2f2d5ad5b9bad31b8848d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0dc7cee91cd2f2d5ad5b9bad31b8848d"></a>
struct <a class="el" href="structcapref.html">capref</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lib_2barrelfish_2capabilities_8c.html#a0dc7cee91cd2f2d5ad5b9bad31b8848d">cap_vroot</a></td></tr>
<tr class="memdesc:a0dc7cee91cd2f2d5ad5b9bad31b8848d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Root PML4 VNode. <br /></td></tr>
<tr class="separator:a0dc7cee91cd2f2d5ad5b9bad31b8848d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Capability system user code. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a2106e8cc8fb701dd3b775e50aad06927"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">errval_t cap_create </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcapref.html">capref</a>&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum objtype&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a capability. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Location where to create the cap, which must be empty. </td></tr>
    <tr><td class="paramname">type</td><td>Kernel object type to create. </td></tr>
    <tr><td class="paramname">size</td><td>Size of the created capability in bytes. (ignored for fixed-size objects)</td></tr>
  </table>
  </dd>
</dl>
<p>Only certain types of capabilities can be created this way. If invoked on a capability type, that is not creatable at runtime the error SYS_ERR_TYPE_NOT_CREATABLE is returned. Most capabilities have to be retyped from other capabilities with <a class="el" href="lib_2barrelfish_2capabilities_8c.html#affa248fd38ad2e189d57f8c842e1a60e" title="Retype (part of) a capability into one or more new capabilities. ">cap_retype()</a>. </p>

</div>
</div>
<a class="anchor" id="a869c261bec2ea52460bb6a27dfeb17e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">errval_t cap_delete </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcapref.html">capref</a>&#160;</td>
          <td class="paramname"><em>cap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete the given capability. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cap</td><td>Capability to be deleted</td></tr>
  </table>
  </dd>
</dl>
<p>Deletes (but does not revoke) the given capability, allowing the CNode slot to be reused. </p>

</div>
</div>
<a class="anchor" id="ab5457f9c30fec400262de48939f2e2b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">errval_t cap_destroy </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcapref.html">capref</a>&#160;</td>
          <td class="paramname"><em>cap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a capability, i.e. delete it and free the slot. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cap</td><td>Capability to be destroyed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="affa248fd38ad2e189d57f8c842e1a60e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">errval_t cap_retype </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcapref.html">capref</a>&#160;</td>
          <td class="paramname"><em>dest_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcapref.html">capref</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gensize_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum objtype&#160;</td>
          <td class="paramname"><em>new_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gensize_t&#160;</td>
          <td class="paramname"><em>objsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retype (part of) a capability into one or more new capabilities. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest_start</td><td>Location of first destination slot, which must be empty </td></tr>
    <tr><td class="paramname">src</td><td>Source capability to retype </td></tr>
    <tr><td class="paramname">offset</td><td>Offset into source capability </td></tr>
    <tr><td class="paramname">new_type</td><td>Kernel object type to retype to. </td></tr>
    <tr><td class="paramname">objsize</td><td>Size of created objects in bytes (ignored for fixed-size objects) </td></tr>
    <tr><td class="paramname">count</td><td>The number of new objects to create</td></tr>
  </table>
  </dd>
</dl>
<p>When retyping IRQSrc capabilities, offset and objsize represent the start and end of the to be created interrupt range. Count must be 1 for IRQSrc.</p>
<p>Retypes (part of) the given source capability into a number of new capabilities, which may be of the same or of different type. The new capabilities are created in the slots starting from dest_start, which must all be empty and lie in the same CNode. The number of objects created is determined by the argument <code>count</code>. </p>

</div>
</div>
<a class="anchor" id="ad3a057363c859fd79d360bf35cb57879"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">errval_t cap_revoke </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcapref.html">capref</a>&#160;</td>
          <td class="paramname"><em>cap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Revoke (delete all copies and descendants of) the given capability. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cap</td><td>Capability to be revoked</td></tr>
  </table>
  </dd>
</dl>
<p>Deletes all copies and descendants of the given capability, but not the capability itself. If this succeeds, the capability is guaranteed to be the only copy in the system. </p>

</div>
</div>
<a class="anchor" id="a0b177f44fbb9477fde222d7c7b523c97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">errval_t cnode_build_cnoderef </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcnoderef.html">cnoderef</a> *&#160;</td>
          <td class="paramname"><em>cnoder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcapref.html">capref</a>&#160;</td>
          <td class="paramname"><em>capr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a <a class="el" href="structcnoderef.html" title="User-level representation of a CNode, this is essentially a capref to a CNode. ">cnoderef</a> struct from a <a class="el" href="structcapref.html" title="User-level representation of a capability and its CSpace address. ">capref</a> struct using cap identification. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cnoder</td><td>Pointer to a cnoderef struct, fill-in by function. </td></tr>
    <tr><td class="paramname">capr</td><td>Capref to a CNode capability. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4c747ee463085fcd5cf3ff13afa91f3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">errval_t cnode_create </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcapref.html">capref</a> *&#160;</td>
          <td class="paramname"><em>ret_dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcnoderef.html">cnoderef</a> *&#160;</td>
          <td class="paramname"><em>cnoderef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cslot_t&#160;</td>
          <td class="paramname"><em>slots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cslot_t *&#160;</td>
          <td class="paramname"><em>retslots</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a CNode from newly-allocated RAM in a newly-allocated slot. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ret_dest</td><td>capref struct to be filled-in with location of CNode </td></tr>
    <tr><td class="paramname">cnoderef</td><td>cnoderef struct, filled-in if non-NULL with relevant info </td></tr>
    <tr><td class="paramname">slots</td><td>Minimum number of slots in created CNode </td></tr>
    <tr><td class="paramname">retslots</td><td>If non-NULL, filled in with the number of slots in created CNode </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="add3751fbddb2bfca91f43cc21053463a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">errval_t cnode_create_foreign_l2 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcapref.html">capref</a>&#160;</td>
          <td class="paramname"><em>dest_l1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cslot_t&#160;</td>
          <td class="paramname"><em>dest_slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcnoderef.html">cnoderef</a> *&#160;</td>
          <td class="paramname"><em>cnoderef</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a CNode for another cspace from newly-allocated RAM in a newly-allocated slot. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest_l1</td><td>capref to L1 (root) cnode of destination cspace </td></tr>
    <tr><td class="paramname">dest_slot</td><td>slot to fill with new cnode in destination L1 cnode </td></tr>
    <tr><td class="paramname">cnoderef</td><td>cnoderef struct, filled-in if non-NULL with relevant info</td></tr>
  </table>
  </dd>
</dl>
<p>This function creates a CNode which contains 256 capabilities initially and puts it in a slot in our cspace. </p>

</div>
</div>
<a class="anchor" id="a119d05e40d9461cc43b39f8e085379ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">errval_t cnode_create_from_mem </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcapref.html">capref</a>&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcapref.html">capref</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum objtype&#160;</td>
          <td class="paramname"><em>cntype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcnoderef.html">cnoderef</a> *&#160;</td>
          <td class="paramname"><em>cnoderef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>slots</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a CNode from a given RAM capability in a specific slot. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>location in which to place newly-created CNode cap </td></tr>
    <tr><td class="paramname">src</td><td>location of RAM capability to be retyped to new CNode </td></tr>
    <tr><td class="paramname">cnoderef</td><td>cnoderef struct, filled-in if non-NULL with relevant info </td></tr>
    <tr><td class="paramname">slots</td><td>number of slots in created CNode must match size of RAM capability.</td></tr>
  </table>
  </dd>
</dl>
<p>This function requires that dest refer to an existing but empty slot. It retypes the given memory to a new CNode. </p>

</div>
</div>
<a class="anchor" id="a4bd7ed7dc87bb7ee598baea3f3eca141"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">errval_t cnode_create_l2 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcapref.html">capref</a> *&#160;</td>
          <td class="paramname"><em>ret_dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcnoderef.html">cnoderef</a> *&#160;</td>
          <td class="paramname"><em>cnoderef</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a L2 CNode from newly-allocated RAM in a newly-allocated slot. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ret_dest</td><td>capref struct to be filled-in with location of CNode </td></tr>
    <tr><td class="paramname">cnoderef</td><td>cnoderef struct, filled-in if non-NULL with relevant info</td></tr>
  </table>
  </dd>
</dl>
<p>This function always creates a L2 CNode which contains 256 capabilities </p>

</div>
</div>
<a class="anchor" id="a8e1ed82615c06db3257d588d37e13e1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">errval_t cnode_create_raw </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcapref.html">capref</a>&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcnoderef.html">cnoderef</a> *&#160;</td>
          <td class="paramname"><em>cnoderef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum objtype&#160;</td>
          <td class="paramname"><em>cntype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cslot_t&#160;</td>
          <td class="paramname"><em>slots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cslot_t *&#160;</td>
          <td class="paramname"><em>retslots</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a CNode from newly-allocated RAM in the given slot. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>location in which to place CNode cap </td></tr>
    <tr><td class="paramname">cnoderef</td><td>cnoderef struct, filled-in if non-NULL with relevant info </td></tr>
    <tr><td class="paramname">cntype,type</td><td>of new cnode </td></tr>
    <tr><td class="paramname">slots</td><td>Minimum number of slots in created CNode </td></tr>
    <tr><td class="paramname">retslots</td><td>If non-NULL, filled in with the number of slots in created CNode</td></tr>
  </table>
  </dd>
</dl>
<p>This function requires that dest refer to an existing but empty slot. It allocates memory (using <a class="el" href="ram__alloc_8c.html#a9aea44f4b26d24f1dd09d3d5a6c94e8b" title="Allocates memory in the form of a RAM capability. ">ram_alloc</a>), and retypes that memory to a new CNode. The intermediate ram cap is destroyed. </p>

</div>
</div>
<a class="anchor" id="ada98fd333297149570bf76792b99a1a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">errval_t cnode_create_with_guard </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcapref.html">capref</a>&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcnoderef.html">cnoderef</a> *&#160;</td>
          <td class="paramname"><em>cnoderef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cslot_t&#160;</td>
          <td class="paramname"><em>slots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cslot_t *&#160;</td>
          <td class="paramname"><em>retslots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>guard</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>guard_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create CNode with a given guard. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Location where to place the cnode </td></tr>
    <tr><td class="paramname">cnoderef</td><td>Filled in cnoderef struct if non-NULL </td></tr>
    <tr><td class="paramname">slots</td><td>Minimum number of slots in created CNode </td></tr>
    <tr><td class="paramname">retslots</td><td>If non-NULL, filled in with the number of slots in created CNode </td></tr>
    <tr><td class="paramname">guard</td><td>The guard value to set </td></tr>
    <tr><td class="paramname">guard_size</td><td>The length of the guard in bits</td></tr>
  </table>
  </dd>
</dl>
<p>This function requires that dest refer to an existing but empty slot. It allocates memory (using <a class="el" href="ram__alloc_8c.html#a9aea44f4b26d24f1dd09d3d5a6c94e8b" title="Allocates memory in the form of a RAM capability. ">ram_alloc</a>), and retypes that memory to a new CNode with the given guard value and size. An intermediate slot is used in order to set the guard value. </p>

</div>
</div>
<a class="anchor" id="a3c85327bee70a3ed0a5d045b9147b952"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">errval_t devframe_type </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcapref.html">capref</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcapref.html">capref</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a DevFrame cap by retyping out of given source PhysAddr cap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Pointer to capref struct, filled-in with location of new cap </td></tr>
    <tr><td class="paramname">src</td><td>Cap_info struct for the source PhysAddr cap </td></tr>
    <tr><td class="paramname">size_bits</td><td>Size of created objects as a power of two (ignored for fixed-size objects) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1a10f4dff0fd4d61e12735ffc0e029e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">errval_t dispatcher_create </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcapref.html">capref</a>&#160;</td>
          <td class="paramname"><em>dest</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a Dispatcher in newly-allocated memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>location to place new dispatcher cap</td></tr>
  </table>
  </dd>
</dl>
<p>This function requires that dest refer to an existing but empty slot. It does not map in nor initialise the Dispatcher. The intermediate ram cap is destroyed. </p>

</div>
</div>
<a class="anchor" id="a9df05ed17aabaaa79e4728c31320ebd5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">errval_t endpoint_create </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buflen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcapref.html">capref</a> *&#160;</td>
          <td class="paramname"><em>retcap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structlmp__endpoint.html">lmp_endpoint</a> **&#160;</td>
          <td class="paramname"><em>retep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create endpoint to caller on current dispatcher. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buflen</td><td>Length of incoming LMP buffer, in words </td></tr>
    <tr><td class="paramname">retcap</td><td>Pointer to capref struct, filled-in with location of cap </td></tr>
    <tr><td class="paramname">retep</td><td>Double pointer to LMP endpoint, filled-in with allocated EP </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae500f89147ca5e20ff4b7e846c027957"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">errval_t frame_alloc </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcapref.html">capref</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>retbytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a Frame cap referring to newly-allocated RAM in an allocated slot. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Pointer to capref struct, filled-in with location of new cap </td></tr>
    <tr><td class="paramname">bytes</td><td>Minimum size of frame to create </td></tr>
    <tr><td class="paramname">retbytes</td><td>If non-NULL, filled in with size of created frame </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afec3c6ac9e37d96b8daa32d2ce7ed69f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">errval_t frame_create </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcapref.html">capref</a>&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>retbytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a Frame cap referring to newly-allocated RAM in a given slot. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Location to place new frame cap </td></tr>
    <tr><td class="paramname">bytes</td><td>Minimum size of frame to create </td></tr>
    <tr><td class="paramname">retbytes</td><td>If non-NULL, filled in with size of created frame</td></tr>
  </table>
  </dd>
</dl>
<p>This function requires that dest refer to an existing but empty slot. <a class="el" href="ram__alloc_8c.html#a9aea44f4b26d24f1dd09d3d5a6c94e8b" title="Allocates memory in the form of a RAM capability. ">ram_alloc</a> is used to allocate memory. After retyping the intermediate ram cap is destroyed.</p>
<p>This function will returns a special error code if ram_alloc fails due to the constrains on the memory server (size of cap or region of memory). This is to facilitate retrying with different constraints. </p>

</div>
</div>
<a class="anchor" id="aaa74c9d2e0e902dce8f6934a05685a70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">errval_t idcap_alloc </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcapref.html">capref</a> *&#160;</td>
          <td class="paramname"><em>dest</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an ID cap in a newly allocated slot. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Pointer to capref struct, filld-in with location of new cap.</td></tr>
  </table>
  </dd>
</dl>
<p>The caller is responsible for revoking the cap after using it. </p>

</div>
</div>
<a class="anchor" id="a4ec020ef8d626833e4dd0d77879ca0d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">errval_t idcap_create </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcapref.html">capref</a>&#160;</td>
          <td class="paramname"><em>dest</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an ID cap in the specified slot. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Capref, where ID cap should be created.</td></tr>
  </table>
  </dd>
</dl>
<p>The caller is responsible for revoking the cap after using it. </p>

</div>
</div>
<a class="anchor" id="acdbebea930c218583af41b83ab28020f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">errval_t root_cnode_resize </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcapref.html">capref</a>&#160;</td>
          <td class="paramname"><em>new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcapref.html">capref</a>&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace own L1 CNode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new</td><td>the replacement L1 CNode </td></tr>
    <tr><td class="paramname">ret</td><td>the slot to put the old L1 CNode </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a859d10247c776dea4bdf9df96a00c4a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">errval_t vnode_create </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcapref.html">capref</a>&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum objtype&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a VNode in newly-allocated memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>location to place new VNode cap </td></tr>
    <tr><td class="paramname">type</td><td>VNode type to create</td></tr>
  </table>
  </dd>
</dl>
<p>This function requires that dest refer to an existing but empty slot. The intermidiate ram cap is destroyed. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
