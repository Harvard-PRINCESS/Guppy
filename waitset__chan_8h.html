<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Barrelfish: include/barrelfish/waitset_chan.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Barrelfish
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_d4e97a57a2af26ed01adfb3ccd13c638.html">barrelfish</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">waitset_chan.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Waitset interface to channel implementations.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a344ed0af7bd00c8c82e732960f19fabb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="waitset__chan_8h.html#a344ed0af7bd00c8c82e732960f19fabb">waitset_chanstate_init</a> (struct <a class="el" href="structwaitset__chanstate.html">waitset_chanstate</a> *chan, enum <a class="el" href="waitset_8h.html#a880bac4851501b8a44a963a827eaf5c9">ws_chantype</a> chantype)</td></tr>
<tr class="memdesc:a344ed0af7bd00c8c82e732960f19fabb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise per-channel waitset state.  <a href="#a344ed0af7bd00c8c82e732960f19fabb">More...</a><br /></td></tr>
<tr class="separator:a344ed0af7bd00c8c82e732960f19fabb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc219231e486b16f7e4098011ecafc3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="waitset__chan_8h.html#afc219231e486b16f7e4098011ecafc3e">waitset_chanstate_destroy</a> (struct <a class="el" href="structwaitset__chanstate.html">waitset_chanstate</a> *chan)</td></tr>
<tr class="memdesc:afc219231e486b16f7e4098011ecafc3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy previously-initialised per-channel waitset state.  <a href="#afc219231e486b16f7e4098011ecafc3e">More...</a><br /></td></tr>
<tr class="separator:afc219231e486b16f7e4098011ecafc3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3729a3900bba1e631da85adba2d1f504"><td class="memItemLeft" align="right" valign="top">errval_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="waitset__chan_8h.html#a3729a3900bba1e631da85adba2d1f504">waitset_chan_trigger</a> (struct <a class="el" href="structwaitset__chanstate.html">waitset_chanstate</a> *chan)</td></tr>
<tr class="memdesc:a3729a3900bba1e631da85adba2d1f504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trigger an event callback on a channel.  <a href="#a3729a3900bba1e631da85adba2d1f504">More...</a><br /></td></tr>
<tr class="separator:a3729a3900bba1e631da85adba2d1f504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14833759596577fb3cb237f63e7e6e6a"><td class="memItemLeft" align="right" valign="top">errval_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="waitset__chan_8h.html#a14833759596577fb3cb237f63e7e6e6a">waitset_chan_trigger_closure</a> (struct <a class="el" href="structwaitset.html">waitset</a> *ws, struct <a class="el" href="structwaitset__chanstate.html">waitset_chanstate</a> *chan, struct event_closure closure)</td></tr>
<tr class="memdesc:a14833759596577fb3cb237f63e7e6e6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trigger a specific event callback on an unregistered channel.  <a href="#a14833759596577fb3cb237f63e7e6e6a">More...</a><br /></td></tr>
<tr class="separator:a14833759596577fb3cb237f63e7e6e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4df2a56f23054a309bacc95cddde775"><td class="memItemLeft" align="right" valign="top">errval_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="waitset__chan_8h.html#ac4df2a56f23054a309bacc95cddde775">waitset_chan_deregister</a> (struct <a class="el" href="structwaitset__chanstate.html">waitset_chanstate</a> *chan)</td></tr>
<tr class="memdesc:ac4df2a56f23054a309bacc95cddde775"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel a previous callback registration.  <a href="#ac4df2a56f23054a309bacc95cddde775">More...</a><br /></td></tr>
<tr class="separator:ac4df2a56f23054a309bacc95cddde775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a827c733ba0938e9e0e21bd3701f699ee"><td class="memItemLeft" align="right" valign="top">errval_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="waitset__chan_8h.html#a827c733ba0938e9e0e21bd3701f699ee">waitset_chan_register</a> (struct <a class="el" href="structwaitset.html">waitset</a> *ws, struct <a class="el" href="structwaitset__chanstate.html">waitset_chanstate</a> *chan, struct event_closure closure)</td></tr>
<tr class="memdesc:a827c733ba0938e9e0e21bd3701f699ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a closure to be called when a channel is triggered.  <a href="#a827c733ba0938e9e0e21bd3701f699ee">More...</a><br /></td></tr>
<tr class="separator:a827c733ba0938e9e0e21bd3701f699ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4d4b78f5095f98f749855a67d14cc90"><td class="memItemLeft" align="right" valign="top">errval_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="waitset__chan_8h.html#ae4d4b78f5095f98f749855a67d14cc90">waitset_chan_register_polled</a> (struct <a class="el" href="structwaitset.html">waitset</a> *ws, struct <a class="el" href="structwaitset__chanstate.html">waitset_chanstate</a> *chan, struct event_closure closure)</td></tr>
<tr class="memdesc:ae4d4b78f5095f98f749855a67d14cc90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a closure on a channel, and mark the channel as polled.  <a href="#ae4d4b78f5095f98f749855a67d14cc90">More...</a><br /></td></tr>
<tr class="separator:ae4d4b78f5095f98f749855a67d14cc90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15efb1731122fb396b3a4f925182c6df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="waitset__chan_8h.html#a15efb1731122fb396b3a4f925182c6df">waitset_chan_migrate</a> (struct <a class="el" href="structwaitset__chanstate.html">waitset_chanstate</a> *chan, struct <a class="el" href="structwaitset.html">waitset</a> *new_ws)</td></tr>
<tr class="memdesc:a15efb1731122fb396b3a4f925182c6df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Migrate callback registrations to a new waitset.  <a href="#a15efb1731122fb396b3a4f925182c6df">More...</a><br /></td></tr>
<tr class="separator:a15efb1731122fb396b3a4f925182c6df"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Waitset interface to channel implementations. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ac4df2a56f23054a309bacc95cddde775"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">errval_t waitset_chan_deregister </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwaitset__chanstate.html">waitset_chanstate</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cancel a previous callback registration. </p>
<p>Remove the registration for a callback on the given channel. This function must only be called when enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>Waitset's per-channel state </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a15efb1731122fb396b3a4f925182c6df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void waitset_chan_migrate </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwaitset__chanstate.html">waitset_chanstate</a> *&#160;</td>
          <td class="paramname"><em>chan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structwaitset.html">waitset</a> *&#160;</td>
          <td class="paramname"><em>new_ws</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Migrate callback registrations to a new waitset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>Old waitset's per-channel state to migrate </td></tr>
    <tr><td class="paramname">new_ws</td><td>New waitset to migrate to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a827c733ba0938e9e0e21bd3701f699ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">errval_t waitset_chan_register </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwaitset.html">waitset</a> *&#160;</td>
          <td class="paramname"><em>ws</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structwaitset__chanstate.html">waitset_chanstate</a> *&#160;</td>
          <td class="paramname"><em>chan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct event_closure&#160;</td>
          <td class="paramname"><em>closure</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a closure to be called when a channel is triggered. </p>
<p>In the Future, call the closure on a thread associated with the waitset when the channel is triggered. Only one closure may be registered per channel state at any one time. This function must only be called when enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ws</td><td>Waitset </td></tr>
    <tr><td class="paramname">chan</td><td>Waitset's per-channel state </td></tr>
    <tr><td class="paramname">closure</td><td>Event handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae4d4b78f5095f98f749855a67d14cc90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">errval_t waitset_chan_register_polled </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwaitset.html">waitset</a> *&#160;</td>
          <td class="paramname"><em>ws</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structwaitset__chanstate.html">waitset_chanstate</a> *&#160;</td>
          <td class="paramname"><em>chan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct event_closure&#160;</td>
          <td class="paramname"><em>closure</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a closure on a channel, and mark the channel as polled. </p>
<p>In the Future, call the closure on a thread associated with the waitset when the channel is triggered. Only one closure may be registered per channel state at any one time. Additionally, mark the channel as polled. This function must only be called when enabled. It is equivalent to calling <a class="el" href="waitset__chan_8h.html#a827c733ba0938e9e0e21bd3701f699ee" title="Register a closure to be called when a channel is triggered. ">waitset_chan_register()</a> followed by waitset_chan_start_polling().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ws</td><td>Waitset </td></tr>
    <tr><td class="paramname">chan</td><td>Waitset's per-channel state </td></tr>
    <tr><td class="paramname">closure</td><td>Event handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3729a3900bba1e631da85adba2d1f504"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">errval_t waitset_chan_trigger </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwaitset__chanstate.html">waitset_chanstate</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trigger an event callback on a channel. </p>
<p>Marks the given channel as having a pending event, causing some future call to <a class="el" href="waitset_8c.html#aa599c6aa4f4cdc65ee663ddc92444b6c" title="Wait for (block) and return next event on given waitset. ">get_next_event()</a> to return the registered closure. This function must only be called when enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>Waitset's per-channel state </td></tr>
    <tr><td class="paramname">disp</td><td>Current dispatcher pointer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a14833759596577fb3cb237f63e7e6e6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">errval_t waitset_chan_trigger_closure </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwaitset.html">waitset</a> *&#160;</td>
          <td class="paramname"><em>ws</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structwaitset__chanstate.html">waitset_chanstate</a> *&#160;</td>
          <td class="paramname"><em>chan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct event_closure&#160;</td>
          <td class="paramname"><em>closure</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trigger a specific event callback on an unregistered channel. </p>
<p>This function is equivalent to <a class="el" href="waitset__chan_8h.html#a827c733ba0938e9e0e21bd3701f699ee" title="Register a closure to be called when a channel is triggered. ">waitset_chan_register()</a> followed by <a class="el" href="waitset__chan_8h.html#a3729a3900bba1e631da85adba2d1f504" title="Trigger an event callback on a channel. ">waitset_chan_trigger()</a>, but avoids unneccessary queue manipulation. This function must only be called when enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ws</td><td>Waitset </td></tr>
    <tr><td class="paramname">chan</td><td>Waitset's per-channel state </td></tr>
    <tr><td class="paramname">closure</td><td>Event handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afc219231e486b16f7e4098011ecafc3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void waitset_chanstate_destroy </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwaitset__chanstate.html">waitset_chanstate</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy previously-initialised per-channel waitset state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>Channel state </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a344ed0af7bd00c8c82e732960f19fabb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void waitset_chanstate_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwaitset__chanstate.html">waitset_chanstate</a> *&#160;</td>
          <td class="paramname"><em>chan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="waitset_8h.html#a880bac4851501b8a44a963a827eaf5c9">ws_chantype</a>&#160;</td>
          <td class="paramname"><em>chantype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise per-channel waitset state. </p>
<p>"Private" functions that are called only by the channel implementations </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>Channel state </td></tr>
    <tr><td class="paramname">chantype</td><td>Channel type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
