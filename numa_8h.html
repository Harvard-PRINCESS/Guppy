<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Barrelfish: include/numa.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Barrelfish
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">numa.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>header specifying the interface of libnuma  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a7e33cf9600a157e12979374b5dd2f05b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#a7e33cf9600a157e12979374b5dd2f05b">NUMA_MAX_NUMNODES</a>&#160;&#160;&#160;16</td></tr>
<tr class="memdesc:a7e33cf9600a157e12979374b5dd2f05b"><td class="mdescLeft">&#160;</td><td class="mdescRight">&lt; the maximum number of nodes supported  <a href="#a7e33cf9600a157e12979374b5dd2f05b">More...</a><br /></td></tr>
<tr class="separator:a7e33cf9600a157e12979374b5dd2f05b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a962f50b92f10c1695b6d1d99f6d7e423"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a962f50b92f10c1695b6d1d99f6d7e423"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#a962f50b92f10c1695b6d1d99f6d7e423">NUMA_NODE_LOCAL</a>&#160;&#160;&#160;((nodeid_t)-1)</td></tr>
<tr class="memdesc:a962f50b92f10c1695b6d1d99f6d7e423"><td class="mdescLeft">&#160;</td><td class="mdescRight">error value for the numa node size <br /></td></tr>
<tr class="separator:a962f50b92f10c1695b6d1d99f6d7e423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27294af215f794ca29a8076c90c0b803"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a27294af215f794ca29a8076c90c0b803"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#a27294af215f794ca29a8076c90c0b803">NUMA_NODE_INVALID</a>&#160;&#160;&#160;((uintptr_t)-1)</td></tr>
<tr class="memdesc:a27294af215f794ca29a8076c90c0b803"><td class="mdescLeft">&#160;</td><td class="mdescRight">error value for invalid cores <br /></td></tr>
<tr class="separator:a27294af215f794ca29a8076c90c0b803"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a1a08fd9e9d2bc74a52122b6142a09740"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1a08fd9e9d2bc74a52122b6142a09740"></a>
typedef enum <a class="el" href="numa_8h.html#a5c7b7ddbb58218f057235d261d668fb5">numa_policy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#a1a08fd9e9d2bc74a52122b6142a09740">numa_policy_t</a></td></tr>
<tr class="memdesc:a1a08fd9e9d2bc74a52122b6142a09740"><td class="mdescLeft">&#160;</td><td class="mdescRight">typedef for the nodemask <br /></td></tr>
<tr class="separator:a1a08fd9e9d2bc74a52122b6142a09740"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a13aab9351af8516c1763e02a175eca6b"><td class="memItemLeft" align="right" valign="top">errval_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#a13aab9351af8516c1763e02a175eca6b">numa_available</a> (void)</td></tr>
<tr class="memdesc:a13aab9351af8516c1763e02a175eca6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks if numa support is available  <a href="#a13aab9351af8516c1763e02a175eca6b">More...</a><br /></td></tr>
<tr class="separator:a13aab9351af8516c1763e02a175eca6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6250a0f165beb6f960a48eeec329d65d"><td class="memItemLeft" align="right" valign="top">nodeid_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#a6250a0f165beb6f960a48eeec329d65d">numa_max_node</a> (void)</td></tr>
<tr class="memdesc:a6250a0f165beb6f960a48eeec329d65d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the highest node number available on the current system.  <a href="#a6250a0f165beb6f960a48eeec329d65d">More...</a><br /></td></tr>
<tr class="separator:a6250a0f165beb6f960a48eeec329d65d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15b30d8531b6205e2499f200d2cfaf8e"><td class="memItemLeft" align="right" valign="top">coreid_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#a15b30d8531b6205e2499f200d2cfaf8e">numa_max_core</a> (void)</td></tr>
<tr class="memdesc:a15b30d8531b6205e2499f200d2cfaf8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the highest ID of the present cores  <a href="#a15b30d8531b6205e2499f200d2cfaf8e">More...</a><br /></td></tr>
<tr class="separator:a15b30d8531b6205e2499f200d2cfaf8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ad28d8439169ef189adfb8baf1db42c"><td class="memItemLeft" align="right" valign="top">nodeid_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#a0ad28d8439169ef189adfb8baf1db42c">numa_current_node</a> (void)</td></tr>
<tr class="memdesc:a0ad28d8439169ef189adfb8baf1db42c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the current node the domain is running on  <a href="#a0ad28d8439169ef189adfb8baf1db42c">More...</a><br /></td></tr>
<tr class="separator:a0ad28d8439169ef189adfb8baf1db42c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d194154604d58b25c907745aca1143"><td class="memItemLeft" align="right" valign="top">nodeid_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#a53d194154604d58b25c907745aca1143">numa_num_possible_nodes</a> (void)</td></tr>
<tr class="memdesc:a53d194154604d58b25c907745aca1143"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the size of the node mask  <a href="#a53d194154604d58b25c907745aca1143">More...</a><br /></td></tr>
<tr class="separator:a53d194154604d58b25c907745aca1143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a925b757db9361d3dc3035fa80d019e6a"><td class="memItemLeft" align="right" valign="top">nodeid_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#a925b757db9361d3dc3035fa80d019e6a">numa_num_configured_nodes</a> (void)</td></tr>
<tr class="memdesc:a925b757db9361d3dc3035fa80d019e6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains the number of all memory nodes in the system.  <a href="#a925b757db9361d3dc3035fa80d019e6a">More...</a><br /></td></tr>
<tr class="separator:a925b757db9361d3dc3035fa80d019e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1ddb8059c8b27647d73e0994d2ff6da"><td class="memItemLeft" align="right" valign="top">struct bitmap *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#ae1ddb8059c8b27647d73e0994d2ff6da">numa_get_mems_allowed</a> (void)</td></tr>
<tr class="memdesc:ae1ddb8059c8b27647d73e0994d2ff6da"><td class="mdescLeft">&#160;</td><td class="mdescRight">obtains the nodes the domain is allowed to allocate memory from  <a href="#ae1ddb8059c8b27647d73e0994d2ff6da">More...</a><br /></td></tr>
<tr class="separator:ae1ddb8059c8b27647d73e0994d2ff6da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e07ec100973905666625bd87445cbf1"><td class="memItemLeft" align="right" valign="top">coreid_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#a4e07ec100973905666625bd87445cbf1">numa_num_configured_cpus</a> (void)</td></tr>
<tr class="memdesc:a4e07ec100973905666625bd87445cbf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the total numberof CPUs in the system  <a href="#a4e07ec100973905666625bd87445cbf1">More...</a><br /></td></tr>
<tr class="separator:a4e07ec100973905666625bd87445cbf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a841103c17ae0296b1e26d675dbd2cd38"><td class="memItemLeft" align="right" valign="top">coreid_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#a841103c17ae0296b1e26d675dbd2cd38">numa_num_task_cpus</a> (void)</td></tr>
<tr class="memdesc:a841103c17ae0296b1e26d675dbd2cd38"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the number of cpus that the calling domain is allowed to use.  <a href="#a841103c17ae0296b1e26d675dbd2cd38">More...</a><br /></td></tr>
<tr class="separator:a841103c17ae0296b1e26d675dbd2cd38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3c6d92331deff801004a2726312a6de"><td class="memItemLeft" align="right" valign="top">nodeid_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#af3c6d92331deff801004a2726312a6de">numa_num_task_nodes</a> (void)</td></tr>
<tr class="memdesc:af3c6d92331deff801004a2726312a6de"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the number of nodes on which the calling domain is allowed to allocate memory  <a href="#af3c6d92331deff801004a2726312a6de">More...</a><br /></td></tr>
<tr class="separator:af3c6d92331deff801004a2726312a6de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f08fdc5f081ab8fd3a340f4cc8351bc"><td class="memItemLeft" align="right" valign="top">errval_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#a7f08fdc5f081ab8fd3a340f4cc8351bc">numa_parse_bitmap</a> (char *line, struct bitmap *mask)</td></tr>
<tr class="memdesc:a7f08fdc5f081ab8fd3a340f4cc8351bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">parses line , which is a character string  <a href="#a7f08fdc5f081ab8fd3a340f4cc8351bc">More...</a><br /></td></tr>
<tr class="separator:a7f08fdc5f081ab8fd3a340f4cc8351bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9c3be9341e2c8e869617695ec9d3d75"><td class="memItemLeft" align="right" valign="top">struct bitmap *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#aa9c3be9341e2c8e869617695ec9d3d75">numa_parse_nodestring</a> (char *string)</td></tr>
<tr class="memdesc:aa9c3be9341e2c8e869617695ec9d3d75"><td class="mdescLeft">&#160;</td><td class="mdescRight">parses a character string list of nodes into a bit mask.  <a href="#aa9c3be9341e2c8e869617695ec9d3d75">More...</a><br /></td></tr>
<tr class="separator:aa9c3be9341e2c8e869617695ec9d3d75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae71e6b96b51ac951752baf95534a4e88"><td class="memItemLeft" align="right" valign="top">struct bitmap *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#ae71e6b96b51ac951752baf95534a4e88">numa_parse_cpustring</a> (char *string)</td></tr>
<tr class="memdesc:ae71e6b96b51ac951752baf95534a4e88"><td class="mdescLeft">&#160;</td><td class="mdescRight">parses a character string list of cpus into a bit mask.  <a href="#ae71e6b96b51ac951752baf95534a4e88">More...</a><br /></td></tr>
<tr class="separator:ae71e6b96b51ac951752baf95534a4e88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5643014e5aefb12eba6368afde85e76f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#a5643014e5aefb12eba6368afde85e76f">numa_node_size</a> (nodeid_t node, uintptr_t *freep)</td></tr>
<tr class="memdesc:a5643014e5aefb12eba6368afde85e76f"><td class="mdescLeft">&#160;</td><td class="mdescRight">obtains the size of a node  <a href="#a5643014e5aefb12eba6368afde85e76f">More...</a><br /></td></tr>
<tr class="separator:a5643014e5aefb12eba6368afde85e76f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a310bf8d9e0d7370c2edce74ca4fba972"><td class="memItemLeft" align="right" valign="top">lpaddr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#a310bf8d9e0d7370c2edce74ca4fba972">numa_node_base</a> (nodeid_t node)</td></tr>
<tr class="memdesc:a310bf8d9e0d7370c2edce74ca4fba972"><td class="mdescLeft">&#160;</td><td class="mdescRight">obtains the base address of the numa node  <a href="#a310bf8d9e0d7370c2edce74ca4fba972">More...</a><br /></td></tr>
<tr class="separator:a310bf8d9e0d7370c2edce74ca4fba972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7485ad57e538dad021aaed704f742f8a"><td class="memItemLeft" align="right" valign="top">nodeid_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#a7485ad57e538dad021aaed704f742f8a">numa_preferred</a> (void)</td></tr>
<tr class="memdesc:a7485ad57e538dad021aaed704f742f8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the preferred node of the current task.  <a href="#a7485ad57e538dad021aaed704f742f8a">More...</a><br /></td></tr>
<tr class="separator:a7485ad57e538dad021aaed704f742f8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bfe6513e958b53670773c66e803942c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#a3bfe6513e958b53670773c66e803942c">numa_set_preferred</a> (nodeid_t node)</td></tr>
<tr class="memdesc:a3bfe6513e958b53670773c66e803942c"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the preferred node for the current task to node  <a href="#a3bfe6513e958b53670773c66e803942c">More...</a><br /></td></tr>
<tr class="separator:a3bfe6513e958b53670773c66e803942c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16ed82504021427c568854931c11bc3b"><td class="memItemLeft" align="right" valign="top">struct bitmap *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#a16ed82504021427c568854931c11bc3b">numa_get_interleave_mask</a> (void)</td></tr>
<tr class="memdesc:a16ed82504021427c568854931c11bc3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the current interleave mask  <a href="#a16ed82504021427c568854931c11bc3b">More...</a><br /></td></tr>
<tr class="separator:a16ed82504021427c568854931c11bc3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d9646ec73af0a36cdd00302da6aeb0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#a4d9646ec73af0a36cdd00302da6aeb0e">numa_set_interleave_mask</a> (struct bitmap *nodemask)</td></tr>
<tr class="memdesc:a4d9646ec73af0a36cdd00302da6aeb0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the memory interleave mask for the current task to nodemask  <a href="#a4d9646ec73af0a36cdd00302da6aeb0e">More...</a><br /></td></tr>
<tr class="separator:a4d9646ec73af0a36cdd00302da6aeb0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02df68ef54915fb3dd10e4ad761fc690"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#a02df68ef54915fb3dd10e4ad761fc690">numa_bind</a> (struct bitmap *nodemask)</td></tr>
<tr class="memdesc:a02df68ef54915fb3dd10e4ad761fc690"><td class="mdescLeft">&#160;</td><td class="mdescRight">binds the current task and its children to the nodes specified in nodemask.  <a href="#a02df68ef54915fb3dd10e4ad761fc690">More...</a><br /></td></tr>
<tr class="separator:a02df68ef54915fb3dd10e4ad761fc690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21a5645afe199400042a64e960a3f14e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21a5645afe199400042a64e960a3f14e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#a21a5645afe199400042a64e960a3f14e">numa_set_localalloc</a> (void)</td></tr>
<tr class="memdesc:a21a5645afe199400042a64e960a3f14e"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the memory allocation policy for the calling task to local allocation. <br /></td></tr>
<tr class="separator:a21a5645afe199400042a64e960a3f14e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03781879a5c16360c1635004f5b3d0ce"><td class="memItemLeft" align="right" valign="top">errval_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#a03781879a5c16360c1635004f5b3d0ce">numa_set_membind</a> (struct bitmap *nodemask)</td></tr>
<tr class="memdesc:a03781879a5c16360c1635004f5b3d0ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the memory allocation mask.  <a href="#a03781879a5c16360c1635004f5b3d0ce">More...</a><br /></td></tr>
<tr class="separator:a03781879a5c16360c1635004f5b3d0ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99fe7a1a08688f1bc6cded282e402a00"><td class="memItemLeft" align="right" valign="top">struct bitmap *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#a99fe7a1a08688f1bc6cded282e402a00">numa_get_membind</a> (void)</td></tr>
<tr class="memdesc:a99fe7a1a08688f1bc6cded282e402a00"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the mask of nodes from which memory can currently be allocated.  <a href="#a99fe7a1a08688f1bc6cded282e402a00">More...</a><br /></td></tr>
<tr class="separator:a99fe7a1a08688f1bc6cded282e402a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd3db7ddd501d9e3cb85d584f93130ce"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#acd3db7ddd501d9e3cb85d584f93130ce">numa_alloc_onnode</a> (size_t size, nodeid_t node, size_t pagesize)</td></tr>
<tr class="memdesc:acd3db7ddd501d9e3cb85d584f93130ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocates memory on a specific node.  <a href="#acd3db7ddd501d9e3cb85d584f93130ce">More...</a><br /></td></tr>
<tr class="separator:acd3db7ddd501d9e3cb85d584f93130ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f47a5441f8af42577bb7ca1be59718"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#a30f47a5441f8af42577bb7ca1be59718">numa_alloc_local</a> (size_t size, size_t pagesize)</td></tr>
<tr class="memdesc:a30f47a5441f8af42577bb7ca1be59718"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocates size bytes of memory on the local node  <a href="#a30f47a5441f8af42577bb7ca1be59718">More...</a><br /></td></tr>
<tr class="separator:a30f47a5441f8af42577bb7ca1be59718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f99eadfe520a1dcd22fb8df721d4461"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#a4f99eadfe520a1dcd22fb8df721d4461">numa_alloc_interleaved</a> (size_t size, size_t pagesize)</td></tr>
<tr class="memdesc:a4f99eadfe520a1dcd22fb8df721d4461"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocates size bytes of memory page interleaved on all nodes.  <a href="#a4f99eadfe520a1dcd22fb8df721d4461">More...</a><br /></td></tr>
<tr class="separator:a4f99eadfe520a1dcd22fb8df721d4461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5b5bb820e6f3b305c265a4a8c0081bb"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#ad5b5bb820e6f3b305c265a4a8c0081bb">numa_alloc_interleaved_subset</a> (size_t size, size_t pagesize, struct bitmap *nodemask)</td></tr>
<tr class="memdesc:ad5b5bb820e6f3b305c265a4a8c0081bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocates size bytes of memory page interleaved the nodes specified in the nodemask.  <a href="#ad5b5bb820e6f3b305c265a4a8c0081bb">More...</a><br /></td></tr>
<tr class="separator:ad5b5bb820e6f3b305c265a4a8c0081bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd4f06373d27d21476015a416007b124"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#acd4f06373d27d21476015a416007b124">numa_alloc</a> (size_t size, size_t pagesize)</td></tr>
<tr class="memdesc:acd4f06373d27d21476015a416007b124"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocates size bytes of memory with the current NUMA policy.  <a href="#acd4f06373d27d21476015a416007b124">More...</a><br /></td></tr>
<tr class="separator:acd4f06373d27d21476015a416007b124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c44a3a92bef81d63508374e66fa133a"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#a1c44a3a92bef81d63508374e66fa133a">numa_realloc</a> (void *old_addr, size_t old_size, size_t new_size)</td></tr>
<tr class="memdesc:a1c44a3a92bef81d63508374e66fa133a"><td class="mdescLeft">&#160;</td><td class="mdescRight">changes the size of the memory area.  <a href="#a1c44a3a92bef81d63508374e66fa133a">More...</a><br /></td></tr>
<tr class="separator:a1c44a3a92bef81d63508374e66fa133a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5daf85598ac258583e4d370de3996052"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#a5daf85598ac258583e4d370de3996052">numa_free</a> (void *start, size_t size)</td></tr>
<tr class="memdesc:a5daf85598ac258583e4d370de3996052"><td class="mdescLeft">&#160;</td><td class="mdescRight">frees size bytes of memory starting at start  <a href="#a5daf85598ac258583e4d370de3996052">More...</a><br /></td></tr>
<tr class="separator:a5daf85598ac258583e4d370de3996052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08290f2d8c7b6bbb437faf33d440100c"><td class="memItemLeft" align="right" valign="top">errval_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#a08290f2d8c7b6bbb437faf33d440100c">numa_frame_alloc_on_node</a> (struct <a class="el" href="structcapref.html">capref</a> *dest, size_t size, nodeid_t node, size_t *ret_size)</td></tr>
<tr class="memdesc:a08290f2d8c7b6bbb437faf33d440100c"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocates a frame on a specific node  <a href="#a08290f2d8c7b6bbb437faf33d440100c">More...</a><br /></td></tr>
<tr class="separator:a08290f2d8c7b6bbb437faf33d440100c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8ca74c62c94baa1a85a2470209f25ce"><td class="memItemLeft" align="right" valign="top">errval_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#ad8ca74c62c94baa1a85a2470209f25ce">numa_frame_free</a> (struct <a class="el" href="structcapref.html">capref</a> frame)</td></tr>
<tr class="memdesc:ad8ca74c62c94baa1a85a2470209f25ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">frees a previously allocated frame  <a href="#ad8ca74c62c94baa1a85a2470209f25ce">More...</a><br /></td></tr>
<tr class="separator:ad8ca74c62c94baa1a85a2470209f25ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab536a7c9a8fd406dce6ec5d5b6a0b5cd"><td class="memItemLeft" align="right" valign="top">errval_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#ab536a7c9a8fd406dce6ec5d5b6a0b5cd">numa_run_on_node</a> (nodeid_t node)</td></tr>
<tr class="memdesc:ab536a7c9a8fd406dce6ec5d5b6a0b5cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">runs the current domain on a specific node.  <a href="#ab536a7c9a8fd406dce6ec5d5b6a0b5cd">More...</a><br /></td></tr>
<tr class="separator:ab536a7c9a8fd406dce6ec5d5b6a0b5cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0b30a5e75cdc6a864d6801434d332bb"><td class="memItemLeft" align="right" valign="top">errval_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#ad0b30a5e75cdc6a864d6801434d332bb">numa_run_on_node_mask</a> (struct bitmap *nodemask)</td></tr>
<tr class="memdesc:ad0b30a5e75cdc6a864d6801434d332bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">runs the current domain only on nodes specified in nodemask.  <a href="#ad0b30a5e75cdc6a864d6801434d332bb">More...</a><br /></td></tr>
<tr class="separator:ad0b30a5e75cdc6a864d6801434d332bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a599d667326886592bf31dcbac927f62f"><td class="memItemLeft" align="right" valign="top">struct bitmap *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#a599d667326886592bf31dcbac927f62f">numa_get_run_node_mask</a> (void)</td></tr>
<tr class="memdesc:a599d667326886592bf31dcbac927f62f"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a mask of CPUs on which the current task is allowed to run.  <a href="#a599d667326886592bf31dcbac927f62f">More...</a><br /></td></tr>
<tr class="separator:a599d667326886592bf31dcbac927f62f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad032bb2992091e05ae5c61aca6f902b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#ad032bb2992091e05ae5c61aca6f902b0">numa_set_bind_policy</a> (<a class="el" href="numa_8h.html#a1a08fd9e9d2bc74a52122b6142a09740">numa_policy_t</a> strict)</td></tr>
<tr class="memdesc:ad032bb2992091e05ae5c61aca6f902b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">specify the memory bind policy  <a href="#ad032bb2992091e05ae5c61aca6f902b0">More...</a><br /></td></tr>
<tr class="separator:ad032bb2992091e05ae5c61aca6f902b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ac29d7b257c787bc1768f6ef6151487"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#a8ac29d7b257c787bc1768f6ef6151487">numa_set_strict</a> (<a class="el" href="numa_8h.html#a1a08fd9e9d2bc74a52122b6142a09740">numa_policy_t</a> strict)</td></tr>
<tr class="memdesc:a8ac29d7b257c787bc1768f6ef6151487"><td class="mdescLeft">&#160;</td><td class="mdescRight">enable or disable the strict allocation policy  <a href="#a8ac29d7b257c787bc1768f6ef6151487">More...</a><br /></td></tr>
<tr class="separator:a8ac29d7b257c787bc1768f6ef6151487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0136be61b635e497141e0a975efb931"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#ae0136be61b635e497141e0a975efb931">numa_distance</a> (nodeid_t from, nodeid_t to)</td></tr>
<tr class="memdesc:ae0136be61b635e497141e0a975efb931"><td class="mdescLeft">&#160;</td><td class="mdescRight">reports the distance in the machine topology between two nodes  <a href="#ae0136be61b635e497141e0a975efb931">More...</a><br /></td></tr>
<tr class="separator:ae0136be61b635e497141e0a975efb931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a534efeb1fdf6965725f260e2a04426"><td class="memItemLeft" align="right" valign="top">errval_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#a6a534efeb1fdf6965725f260e2a04426">numa_sched_getaffinity</a> (domainid_t did, struct bitmap *mask)</td></tr>
<tr class="memdesc:a6a534efeb1fdf6965725f260e2a04426"><td class="mdescLeft">&#160;</td><td class="mdescRight">retrieves a bitmask of the cpus on which a domain may run  <a href="#a6a534efeb1fdf6965725f260e2a04426">More...</a><br /></td></tr>
<tr class="separator:a6a534efeb1fdf6965725f260e2a04426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb2dfcff1f36a11ff4d93fb05409d24d"><td class="memItemLeft" align="right" valign="top">errval_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#afb2dfcff1f36a11ff4d93fb05409d24d">numa_sched_setaffinity</a> (domainid_t did, struct bitmap *mask)</td></tr>
<tr class="memdesc:afb2dfcff1f36a11ff4d93fb05409d24d"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets a domain's allowed cpu's to those cpu's specified in mask.  <a href="#afb2dfcff1f36a11ff4d93fb05409d24d">More...</a><br /></td></tr>
<tr class="separator:afb2dfcff1f36a11ff4d93fb05409d24d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a513a087c427fdfdbb8510faa7a8f8af8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#a513a087c427fdfdbb8510faa7a8f8af8">numa_pagesize</a> (void)</td></tr>
<tr class="memdesc:a513a087c427fdfdbb8510faa7a8f8af8"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the page size  <a href="#a513a087c427fdfdbb8510faa7a8f8af8">More...</a><br /></td></tr>
<tr class="separator:a513a087c427fdfdbb8510faa7a8f8af8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a305bad31ff914f41339eec5243b97044"><td class="memItemLeft" align="right" valign="top">errval_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#a305bad31ff914f41339eec5243b97044">numa_node_to_cpus</a> (nodeid_t node, struct bitmap *mask)</td></tr>
<tr class="memdesc:a305bad31ff914f41339eec5243b97044"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts a node number to a bitmask of CPUs  <a href="#a305bad31ff914f41339eec5243b97044">More...</a><br /></td></tr>
<tr class="separator:a305bad31ff914f41339eec5243b97044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cc73f3c47d5c97040e9ca1223bd11fb"><td class="memItemLeft" align="right" valign="top">coreid_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#a4cc73f3c47d5c97040e9ca1223bd11fb">numa_num_node_cpus</a> (nodeid_t node)</td></tr>
<tr class="memdesc:a4cc73f3c47d5c97040e9ca1223bd11fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets the number of cores for the given numa node  <a href="#a4cc73f3c47d5c97040e9ca1223bd11fb">More...</a><br /></td></tr>
<tr class="separator:a4cc73f3c47d5c97040e9ca1223bd11fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab476eca147de64eb11ad7582c660e746"><td class="memItemLeft" align="right" valign="top">coreid_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#ab476eca147de64eb11ad7582c660e746">numa_node_get_core</a> (nodeid_t node, coreid_t local_core_id)</td></tr>
<tr class="memdesc:ab476eca147de64eb11ad7582c660e746"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets the system's core ID for a node/local core id configuration  <a href="#ab476eca147de64eb11ad7582c660e746">More...</a><br /></td></tr>
<tr class="separator:ab476eca147de64eb11ad7582c660e746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad122c91b4830995004e08fc1390cfcdb"><td class="memItemLeft" align="right" valign="top">nodeid_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#ad122c91b4830995004e08fc1390cfcdb">numa_node_of_cpu</a> (coreid_t cpu)</td></tr>
<tr class="memdesc:ad122c91b4830995004e08fc1390cfcdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the node that a cpu belongs to  <a href="#ad122c91b4830995004e08fc1390cfcdb">More...</a><br /></td></tr>
<tr class="separator:ad122c91b4830995004e08fc1390cfcdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b8059f359f770d0bec20cd5d1995382"><td class="memItemLeft" align="right" valign="top">struct bitmap *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#a7b8059f359f770d0bec20cd5d1995382">numa_allocate_cpumask</a> (void)</td></tr>
<tr class="memdesc:a7b8059f359f770d0bec20cd5d1995382"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocates a bit mask to represent the cores in the system  <a href="#a7b8059f359f770d0bec20cd5d1995382">More...</a><br /></td></tr>
<tr class="separator:a7b8059f359f770d0bec20cd5d1995382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe718e59a733cd6bd6b150a25c578fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#a1fe718e59a733cd6bd6b150a25c578fa">numa_free_cpumask</a> (struct bitmap *cpumask)</td></tr>
<tr class="memdesc:a1fe718e59a733cd6bd6b150a25c578fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">frees a previously allocated CPU bitmask  <a href="#a1fe718e59a733cd6bd6b150a25c578fa">More...</a><br /></td></tr>
<tr class="separator:a1fe718e59a733cd6bd6b150a25c578fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea7bb87c1aa172783a2214482dc618f"><td class="memItemLeft" align="right" valign="top">struct bitmap *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#a8ea7bb87c1aa172783a2214482dc618f">numa_allocate_nodemask</a> (void)</td></tr>
<tr class="memdesc:a8ea7bb87c1aa172783a2214482dc618f"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocates a bit mask to represent the nodes in the system  <a href="#a8ea7bb87c1aa172783a2214482dc618f">More...</a><br /></td></tr>
<tr class="separator:a8ea7bb87c1aa172783a2214482dc618f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43978141ec7fa1f3a6e88df8d6360ce8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#a43978141ec7fa1f3a6e88df8d6360ce8">numa_free_nodemask</a> (struct bitmap *nodemask)</td></tr>
<tr class="memdesc:a43978141ec7fa1f3a6e88df8d6360ce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">frees a previously allocated node bitmask  <a href="#a43978141ec7fa1f3a6e88df8d6360ce8">More...</a><br /></td></tr>
<tr class="separator:a43978141ec7fa1f3a6e88df8d6360ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2990954b2f58781c1b3025f2cb3b5ab9"><td class="memItemLeft" align="right" valign="top">struct bitmap *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#a2990954b2f58781c1b3025f2cb3b5ab9">numa_bitmask_alloc</a> (unsigned int n)</td></tr>
<tr class="memdesc:a2990954b2f58781c1b3025f2cb3b5ab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocates a bitmask structure and its associated bit mask  <a href="#a2990954b2f58781c1b3025f2cb3b5ab9">More...</a><br /></td></tr>
<tr class="separator:a2990954b2f58781c1b3025f2cb3b5ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4214af5206ebc7ddc5ad92c778cdfb1"><td class="memItemLeft" align="right" valign="top">struct bitmap *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#ae4214af5206ebc7ddc5ad92c778cdfb1">numa_bitmask_clearall</a> (struct bitmap *bmp)</td></tr>
<tr class="memdesc:ae4214af5206ebc7ddc5ad92c778cdfb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets all bits in the bit mask to 0.  <a href="#ae4214af5206ebc7ddc5ad92c778cdfb1">More...</a><br /></td></tr>
<tr class="separator:ae4214af5206ebc7ddc5ad92c778cdfb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28ae6d9568da713c8fa15d48b434b764"><td class="memItemLeft" align="right" valign="top">struct bitmap *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#a28ae6d9568da713c8fa15d48b434b764">numa_bitmask_clearbit</a> (struct bitmap *bmp, unsigned int n)</td></tr>
<tr class="memdesc:a28ae6d9568da713c8fa15d48b434b764"><td class="mdescLeft">&#160;</td><td class="mdescRight">clears the n-th bit of a bitmask  <a href="#a28ae6d9568da713c8fa15d48b434b764">More...</a><br /></td></tr>
<tr class="separator:a28ae6d9568da713c8fa15d48b434b764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a52f082f60299c658eccc7412ab57a1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#a9a52f082f60299c658eccc7412ab57a1">numa_bitmask_equal</a> (const struct bitmap *bmp1, const struct bitmap *bmp2)</td></tr>
<tr class="memdesc:a9a52f082f60299c658eccc7412ab57a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks if two bitmasks are equal  <a href="#a9a52f082f60299c658eccc7412ab57a1">More...</a><br /></td></tr>
<tr class="separator:a9a52f082f60299c658eccc7412ab57a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbef6dd58eef256b29935704e873dcec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#afbef6dd58eef256b29935704e873dcec">numa_bitmask_free</a> (struct bitmap *bmp)</td></tr>
<tr class="memdesc:afbef6dd58eef256b29935704e873dcec"><td class="mdescLeft">&#160;</td><td class="mdescRight">frees the memory of a bitmask  <a href="#afbef6dd58eef256b29935704e873dcec">More...</a><br /></td></tr>
<tr class="separator:afbef6dd58eef256b29935704e873dcec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33d34bc65b3430011573341318dcaf9c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#a33d34bc65b3430011573341318dcaf9c">numa_bitmask_isbitset</a> (const struct bitmap *bmp, unsigned int n)</td></tr>
<tr class="memdesc:a33d34bc65b3430011573341318dcaf9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks if the n-th bit is set in the bitmask  <a href="#a33d34bc65b3430011573341318dcaf9c">More...</a><br /></td></tr>
<tr class="separator:a33d34bc65b3430011573341318dcaf9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11c5a31a58ed7ab49ca1db135ccb6679"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#a11c5a31a58ed7ab49ca1db135ccb6679">numa_bitmask_nbytes</a> (struct bitmap *bmp)</td></tr>
<tr class="memdesc:a11c5a31a58ed7ab49ca1db135ccb6679"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the size (in bytes) of the bit mask  <a href="#a11c5a31a58ed7ab49ca1db135ccb6679">More...</a><br /></td></tr>
<tr class="separator:a11c5a31a58ed7ab49ca1db135ccb6679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a75e34491bc5d16b06883c01151b5a6"><td class="memItemLeft" align="right" valign="top">struct bitmap *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#a3a75e34491bc5d16b06883c01151b5a6">numa_bitmask_setall</a> (struct bitmap *bmp)</td></tr>
<tr class="memdesc:a3a75e34491bc5d16b06883c01151b5a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets all bits of a bitmask to 1  <a href="#a3a75e34491bc5d16b06883c01151b5a6">More...</a><br /></td></tr>
<tr class="separator:a3a75e34491bc5d16b06883c01151b5a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87e6bde0bdcdd8032f0a40e3b7c20ec3"><td class="memItemLeft" align="right" valign="top">struct bitmap *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#a87e6bde0bdcdd8032f0a40e3b7c20ec3">numa_bitmask_setbit</a> (struct bitmap *bmp, unsigned int n)</td></tr>
<tr class="memdesc:a87e6bde0bdcdd8032f0a40e3b7c20ec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the n-th bit of a bitmask to 1  <a href="#a87e6bde0bdcdd8032f0a40e3b7c20ec3">More...</a><br /></td></tr>
<tr class="separator:a87e6bde0bdcdd8032f0a40e3b7c20ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1d805b846530a5c69d035126ef630c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#aa1d805b846530a5c69d035126ef630c7">copy_bitmask_to_nodemask</a> (struct bitmap *bmp, nodemask_t *nodemask)</td></tr>
<tr class="memdesc:aa1d805b846530a5c69d035126ef630c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">copies the bitmask to a nodemask  <a href="#aa1d805b846530a5c69d035126ef630c7">More...</a><br /></td></tr>
<tr class="separator:aa1d805b846530a5c69d035126ef630c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20f46e08a8cd95182dbb7b65314fb5bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#a20f46e08a8cd95182dbb7b65314fb5bc">copy_nodemask_to_bitmask</a> (nodemask_t *nodemask, struct bitmap *bmp)</td></tr>
<tr class="memdesc:a20f46e08a8cd95182dbb7b65314fb5bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">copies the contents of a nodemask into the bitmask  <a href="#a20f46e08a8cd95182dbb7b65314fb5bc">More...</a><br /></td></tr>
<tr class="separator:a20f46e08a8cd95182dbb7b65314fb5bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614e919bb318430ec0e40f6f68b0a918"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#a614e919bb318430ec0e40f6f68b0a918">copy_bitmask_to_bitmask</a> (struct bitmap *bmpfrom, struct bitmap *bmpto)</td></tr>
<tr class="memdesc:a614e919bb318430ec0e40f6f68b0a918"><td class="mdescLeft">&#160;</td><td class="mdescRight">copies one bitmask into another  <a href="#a614e919bb318430ec0e40f6f68b0a918">More...</a><br /></td></tr>
<tr class="separator:a614e919bb318430ec0e40f6f68b0a918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1db0339d0ff01afe11b91734b4adcf58"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#a1db0339d0ff01afe11b91734b4adcf58">numa_bitmask_weight</a> (const struct bitmap *bmp)</td></tr>
<tr class="memdesc:a1db0339d0ff01afe11b91734b4adcf58"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a count of the bits that are set in the body of the bitmask  <a href="#a1db0339d0ff01afe11b91734b4adcf58">More...</a><br /></td></tr>
<tr class="separator:a1db0339d0ff01afe11b91734b4adcf58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e74f430630f05f1dbc12d45dc4638f6"><td class="memItemLeft" align="right" valign="top">errval_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#a8e74f430630f05f1dbc12d45dc4638f6">numa_move_pages</a> (domainid_t did, size_t count, void **pages, const nodeid_t *nodes, errval_t *status, int flags)</td></tr>
<tr class="memdesc:a8e74f430630f05f1dbc12d45dc4638f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">moves a list of pages in the address space of the current domain  <a href="#a8e74f430630f05f1dbc12d45dc4638f6">More...</a><br /></td></tr>
<tr class="separator:a8e74f430630f05f1dbc12d45dc4638f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa268e8a2d18fa839340f83da097007f7"><td class="memItemLeft" align="right" valign="top">errval_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#aa268e8a2d18fa839340f83da097007f7">numa_migrate_pages</a> (domainid_t did, struct bitmap *fromnodes, struct bitmap *tonodes)</td></tr>
<tr class="memdesc:aa268e8a2d18fa839340f83da097007f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">migrate a domain from one set of nodes to another  <a href="#aa268e8a2d18fa839340f83da097007f7">More...</a><br /></td></tr>
<tr class="separator:aa268e8a2d18fa839340f83da097007f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5734bdf979b3ccf471a94127a909d1f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#a5734bdf979b3ccf471a94127a909d1f7">numa_error</a> (char *where)</td></tr>
<tr class="separator:a5734bdf979b3ccf471a94127a909d1f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa4c95e6de6697f9260b075825a151d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#afa4c95e6de6697f9260b075825a151d2">numa_warn</a> (int number, char *where,...)</td></tr>
<tr class="separator:afa4c95e6de6697f9260b075825a151d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a854c7059f7302dfdf7a64ea5032af586"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a854c7059f7302dfdf7a64ea5032af586"></a>
struct bitmap *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#a854c7059f7302dfdf7a64ea5032af586">numa_all_nodes_ptr</a></td></tr>
<tr class="memdesc:a854c7059f7302dfdf7a64ea5032af586"><td class="mdescLeft">&#160;</td><td class="mdescRight">bitmask that is allocated by the library with bits representing all nodes on which the calling task may allocate memory. <br /></td></tr>
<tr class="separator:a854c7059f7302dfdf7a64ea5032af586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f1c993f2aee4f105e3434dc3235149a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f1c993f2aee4f105e3434dc3235149a"></a>
struct bitmap *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#a5f1c993f2aee4f105e3434dc3235149a">numa_no_nodes_ptr</a></td></tr>
<tr class="memdesc:a5f1c993f2aee4f105e3434dc3235149a"><td class="mdescLeft">&#160;</td><td class="mdescRight">points to a bitmask that is allocated by the library and left all zeroes. <br /></td></tr>
<tr class="separator:a5f1c993f2aee4f105e3434dc3235149a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a816f78a09ae8da64af38fe360cc1da95"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a816f78a09ae8da64af38fe360cc1da95"></a>
struct bitmap *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="numa_8h.html#a816f78a09ae8da64af38fe360cc1da95">numa_all_cpus_ptr</a></td></tr>
<tr class="memdesc:a816f78a09ae8da64af38fe360cc1da95"><td class="mdescLeft">&#160;</td><td class="mdescRight">points to a bitmask that is allocated by the library with bits representing all cpus on which the calling task may execute. <br /></td></tr>
<tr class="separator:a816f78a09ae8da64af38fe360cc1da95"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>header specifying the interface of libnuma </p>
<p>This is derived from:</p>
<p>Linux man pages "numa" libnuma from <a href="http://oss.sgi.com/projects/libnuma/">http://oss.sgi.com/projects/libnuma/</a> </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a7e33cf9600a157e12979374b5dd2f05b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NUMA_MAX_NUMNODES&#160;&#160;&#160;16</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>&lt; the maximum number of nodes supported </p>
<p>specify the local node for allocation </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a5c7b7ddbb58218f057235d261d668fb5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="numa_8h.html#a5c7b7ddbb58218f057235d261d668fb5">numa_policy</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a5c7b7ddbb58218f057235d261d668fb5a7d3745cd289fafeababca0e2dd950f6a"></a>NUMA_POLICY_DEFAULT&#160;</td><td class="fielddoc">
<p>default numa policy </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a5c7b7ddbb58218f057235d261d668fb5a0f59a83cf66d911d395e647362447123"></a>NUMA_POLICY_STRICT&#160;</td><td class="fielddoc">
<p>strict numa policy </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a5c7b7ddbb58218f057235d261d668fb5a0aa7721ed9f1ec9d1d5db504237bc0de"></a>NUMA_POLICY_PREFERRED&#160;</td><td class="fielddoc">
<p>preferred memory policy </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a614e919bb318430ec0e40f6f68b0a918"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void copy_bitmask_to_bitmask </td>
          <td>(</td>
          <td class="paramtype">struct bitmap *&#160;</td>
          <td class="paramname"><em>bmpfrom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct bitmap *&#160;</td>
          <td class="paramname"><em>bmpto</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>copies one bitmask into another </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bmpfrom</td><td>the source bitmask </td></tr>
    <tr><td class="paramname">bmpto</td><td>the destination bitmask</td></tr>
  </table>
  </dd>
</dl>
<p>If the two areas differ in size, the copy is truncated to the size of the receiving field or zero-filled. </p>

</div>
</div>
<a class="anchor" id="aa1d805b846530a5c69d035126ef630c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void copy_bitmask_to_nodemask </td>
          <td>(</td>
          <td class="paramtype">struct bitmap *&#160;</td>
          <td class="paramname"><em>bmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nodemask_t *&#160;</td>
          <td class="paramname"><em>nodemask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>copies the bitmask to a nodemask </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bmp</td><td>the bitmask to copy </td></tr>
    <tr><td class="paramname">nodemask</td><td>the destination nodemask</td></tr>
  </table>
  </dd>
</dl>
<p>If the two areas differ in size, the copy is truncated to the size of the receiving field or zero-filled. </p>

</div>
</div>
<a class="anchor" id="a20f46e08a8cd95182dbb7b65314fb5bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void copy_nodemask_to_bitmask </td>
          <td>(</td>
          <td class="paramtype">nodemask_t *&#160;</td>
          <td class="paramname"><em>nodemask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct bitmap *&#160;</td>
          <td class="paramname"><em>bmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>copies the contents of a nodemask into the bitmask </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodemask</td><td>node mask to copy from </td></tr>
    <tr><td class="paramname">bmp</td><td>bitmap to copy into</td></tr>
  </table>
  </dd>
</dl>
<p>If the two areas differ in size, the copy is truncated to the size of the receiving field or zero-filled. </p>

</div>
</div>
<a class="anchor" id="acd4f06373d27d21476015a416007b124"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* numa_alloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pagesize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>allocates size bytes of memory with the current NUMA policy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>size of the memory region in bytes </td></tr>
    <tr><td class="paramname">pagesize</td><td>page size to be used for the mapping </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the mapped memory region</dd></dl>
<p>The memory must be freed with <a class="el" href="alloc_8c.html#a5daf85598ac258583e4d370de3996052" title="frees size bytes of memory starting at start ">numa_free()</a>. On errors NULL is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>size of the memory region in bytes </td></tr>
    <tr><td class="paramname">pagesize</td><td>preferred page size to be used </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the mapped memory region</dd></dl>
<p>The memory must be freed with <a class="el" href="alloc_8c.html#a5daf85598ac258583e4d370de3996052" title="frees size bytes of memory starting at start ">numa_free()</a>. On errors NULL is returned. </p>

</div>
</div>
<a class="anchor" id="a4f99eadfe520a1dcd22fb8df721d4461"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* numa_alloc_interleaved </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pagesize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>allocates size bytes of memory page interleaved on all nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>size of the memory region in bytes </td></tr>
    <tr><td class="paramname">pagesize</td><td>page size to be used for the mapping</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the mapped memory region</dd></dl>
<p>should only be used for large areas consisting of multiple pages. The memory must be freed with <a class="el" href="alloc_8c.html#a5daf85598ac258583e4d370de3996052" title="frees size bytes of memory starting at start ">numa_free()</a>. On errors NULL is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>size of the memory region in bytes </td></tr>
    <tr><td class="paramname">pagesize</td><td>preferred page size to be used</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the mapped memory region</dd></dl>
<p>should only be used for large areas consisting of multiple pages. The memory must be freed with <a class="el" href="alloc_8c.html#a5daf85598ac258583e4d370de3996052" title="frees size bytes of memory starting at start ">numa_free()</a>. On errors NULL is returned. </p>

</div>
</div>
<a class="anchor" id="ad5b5bb820e6f3b305c265a4a8c0081bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* numa_alloc_interleaved_subset </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pagesize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct bitmap *&#160;</td>
          <td class="paramname"><em>nodemask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>allocates size bytes of memory page interleaved the nodes specified in the nodemask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>size of the memory region in bytes </td></tr>
    <tr><td class="paramname">nodemask</td><td>subset of nodes to consider for allocation </td></tr>
    <tr><td class="paramname">pagesize</td><td>page size to be used for the mapping</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the mapped memory region</dd></dl>
<p>should only be used for large areas consisting of multiple pages. The memory must be freed with <a class="el" href="alloc_8c.html#a5daf85598ac258583e4d370de3996052" title="frees size bytes of memory starting at start ">numa_free()</a>. On errors NULL is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>size of the memory region in bytes </td></tr>
    <tr><td class="paramname">nodemask</td><td>subset of nodes to consider for allocation </td></tr>
    <tr><td class="paramname">pagesize</td><td>preferred page size to be used</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the mapped memory region</dd></dl>
<p>should only be used for large areas consisting of multiple pages. The memory must be freed with <a class="el" href="alloc_8c.html#a5daf85598ac258583e4d370de3996052" title="frees size bytes of memory starting at start ">numa_free()</a>. On errors NULL is returned. </p>

</div>
</div>
<a class="anchor" id="a30f47a5441f8af42577bb7ca1be59718"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* numa_alloc_local </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pagesize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>allocates size bytes of memory on the local node </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>size of the memory region in bytes </td></tr>
    <tr><td class="paramname">pagesize</td><td>page size to be used for the mapping</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to memory region</dd></dl>
<p>The memory must be freed with <a class="el" href="numa_8h.html#a5daf85598ac258583e4d370de3996052" title="frees size bytes of memory starting at start ">numa_free()</a>. On errors NULL is returned. </p>

</div>
</div>
<a class="anchor" id="acd3db7ddd501d9e3cb85d584f93130ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* numa_alloc_onnode </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nodeid_t&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pagesize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>allocates memory on a specific node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>size of the region in bytes </td></tr>
    <tr><td class="paramname">node</td><td>ID of the node to allocate from </td></tr>
    <tr><td class="paramname">pagesize</td><td>page size to be used for the mapping</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to memory region</dd></dl>
<p>The size argument will be rounded up to a multiple of the system page size. if the specified node is externally denied to this process, this call will fail. The memory must be freed with <a class="el" href="numa_8h.html#a5daf85598ac258583e4d370de3996052" title="frees size bytes of memory starting at start ">numa_free()</a>. On errors NULL is returned. </p>

</div>
</div>
<a class="anchor" id="a7b8059f359f770d0bec20cd5d1995382"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct bitmap* numa_allocate_cpumask </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>allocates a bit mask to represent the cores in the system </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to a new bitmask NULL on failure</dd></dl>
<p>allocates a bit mask to represent the cores in the system</p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a8ea7bb87c1aa172783a2214482dc618f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct bitmap* numa_allocate_nodemask </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>allocates a bit mask to represent the nodes in the system </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to a new bitmask NULL on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a13aab9351af8516c1763e02a175eca6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">errval_t numa_available </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>checks if numa support is available </p>
<dl class="section return"><dt>Returns</dt><dd>NUMA_ERR_NOT_AVAILABLE value all other functions are undefined SYS_ERR_OK: NUMA functionality is available</dd></dl>
<p>this function must be called before any of the other functions of libnuma. during the call to numa_available the library also gets initialized </p>

</div>
</div>
<a class="anchor" id="a02df68ef54915fb3dd10e4ad761fc690"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void numa_bind </td>
          <td>(</td>
          <td class="paramtype">struct bitmap *&#160;</td>
          <td class="paramname"><em>nodemask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>binds the current task and its children to the nodes specified in nodemask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodemask</td><td>bitmap representing the nodes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2990954b2f58781c1b3025f2cb3b5ab9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct bitmap* numa_bitmask_alloc </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>allocates a bitmask structure and its associated bit mask </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the number of bits</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the bitmask NULL on error </dd></dl>

</div>
</div>
<a class="anchor" id="ae4214af5206ebc7ddc5ad92c778cdfb1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct bitmap* numa_bitmask_clearall </td>
          <td>(</td>
          <td class="paramtype">struct bitmap *&#160;</td>
          <td class="paramname"><em>bmp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sets all bits in the bit mask to 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bmp</td><td>pointer to the bitmap</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the cleared bit map </dd></dl>

</div>
</div>
<a class="anchor" id="a28ae6d9568da713c8fa15d48b434b764"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct bitmap* numa_bitmask_clearbit </td>
          <td>(</td>
          <td class="paramtype">struct bitmap *&#160;</td>
          <td class="paramname"><em>bmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>clears the n-th bit of a bitmask </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bmp</td><td>the bitmask </td></tr>
    <tr><td class="paramname">n</td><td>the bit to clear</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the bitmask </dd></dl>

</div>
</div>
<a class="anchor" id="a9a52f082f60299c658eccc7412ab57a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool numa_bitmask_equal </td>
          <td>(</td>
          <td class="paramtype">const struct bitmap *&#160;</td>
          <td class="paramname"><em>bmp1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct bitmap *&#160;</td>
          <td class="paramname"><em>bmp2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>checks if two bitmasks are equal </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bmp1</td><td>bitmask 1 </td></tr>
    <tr><td class="paramname">bmp2</td><td>bitmask 2</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the bitmasks are equal FALSE if the are distinct </dd></dl>

</div>
</div>
<a class="anchor" id="afbef6dd58eef256b29935704e873dcec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void numa_bitmask_free </td>
          <td>(</td>
          <td class="paramtype">struct bitmap *&#160;</td>
          <td class="paramname"><em>bmp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>frees the memory of a bitmask </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bmp</td><td>the bitmask to be freed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a33d34bc65b3430011573341318dcaf9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool numa_bitmask_isbitset </td>
          <td>(</td>
          <td class="paramtype">const struct bitmap *&#160;</td>
          <td class="paramname"><em>bmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>checks if the n-th bit is set in the bitmask </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bmp</td><td>the bitmap </td></tr>
    <tr><td class="paramname">n</td><td>which bit to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the n-th bit is set FALSE otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a11c5a31a58ed7ab49ca1db135ccb6679"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t numa_bitmask_nbytes </td>
          <td>(</td>
          <td class="paramtype">struct bitmap *&#160;</td>
          <td class="paramname"><em>bmp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the size (in bytes) of the bit mask </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bmp</td><td>the bitmask</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size of the memory in bytes rounded up to a multiple of wordsize </dd></dl>

</div>
</div>
<a class="anchor" id="a3a75e34491bc5d16b06883c01151b5a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct bitmap* numa_bitmask_setall </td>
          <td>(</td>
          <td class="paramtype">struct bitmap *&#160;</td>
          <td class="paramname"><em>bmp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sets all bits of a bitmask to 1 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bmp</td><td>the bitmask</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the bitmask </dd></dl>

</div>
</div>
<a class="anchor" id="a87e6bde0bdcdd8032f0a40e3b7c20ec3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct bitmap* numa_bitmask_setbit </td>
          <td>(</td>
          <td class="paramtype">struct bitmap *&#160;</td>
          <td class="paramname"><em>bmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sets the n-th bit of a bitmask to 1 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bmp</td><td>the bitmask </td></tr>
    <tr><td class="paramname">n</td><td>which bit to activate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the bitmask </dd></dl>

</div>
</div>
<a class="anchor" id="a1db0339d0ff01afe11b91734b4adcf58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t numa_bitmask_weight </td>
          <td>(</td>
          <td class="paramtype">const struct bitmap *&#160;</td>
          <td class="paramname"><em>bmp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns a count of the bits that are set in the body of the bitmask </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bmp</td><td>the bitmask to count the set bits</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of set bits in this bitmask </dd></dl>

</div>
</div>
<a class="anchor" id="a0ad28d8439169ef189adfb8baf1db42c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nodeid_t numa_current_node </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the current node the domain is running on </p>
<dl class="section return"><dt>Returns</dt><dd>ID of the current node </dd></dl>

</div>
</div>
<a class="anchor" id="ae0136be61b635e497141e0a975efb931"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t numa_distance </td>
          <td>(</td>
          <td class="paramtype">nodeid_t&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nodeid_t&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reports the distance in the machine topology between two nodes </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>source node to measure the distance </td></tr>
    <tr><td class="paramname">to</td><td>target node to measure the distance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>distance between two nodes 0 iff cannot be deterimed</dd></dl>
<p>The factors are a multiple of 10. A node has distance 10 to itself. </p>

</div>
</div>
<a class="anchor" id="a5734bdf979b3ccf471a94127a909d1f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void numa_error </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>where</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>is a libnuma internal function that can be overridden by the user program. This function is called with a char * argument when a libnuma function fails. Overriding the library internal definition makes it possible to specify a different error handling strategy when a libnuma function fails. It does not affect <a class="el" href="numa_8h.html#a13aab9351af8516c1763e02a175eca6b" title="checks if numa support is available ">numa_available()</a>. The <a class="el" href="numa_8h.html#a5734bdf979b3ccf471a94127a909d1f7">numa_error()</a> function defined in libnuma prints an error on stderr and terminates the program if numa_exit_on_error is set to a non-zero value. The default value of numa_exit_on_error is zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">where</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a08290f2d8c7b6bbb437faf33d440100c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">errval_t numa_frame_alloc_on_node </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcapref.html">capref</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nodeid_t&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>ret_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>allocates a frame on a specific node </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>capref to store the frame </td></tr>
    <tr><td class="paramname">size</td><td>size of the frame to allocated </td></tr>
    <tr><td class="paramname">node</td><td>node on which the frame should be allocated </td></tr>
    <tr><td class="paramname">ret_size</td><td>returned size of the frame capability</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SYS_ERR_OK on SUCCESS errval on FAILURE </dd></dl>

</div>
</div>
<a class="anchor" id="ad8ca74c62c94baa1a85a2470209f25ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">errval_t numa_frame_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcapref.html">capref</a>&#160;</td>
          <td class="paramname"><em>frame</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>frees a previously allocated frame </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame</td><td>capability to free </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5daf85598ac258583e4d370de3996052"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void numa_free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>frees size bytes of memory starting at start </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>start of the memory region </td></tr>
    <tr><td class="paramname">size</td><td>number of bytes to free</td></tr>
  </table>
  </dd>
</dl>
<p>the memory must be previously allocated by one of the numa_alloc* functions </p>

</div>
</div>
<a class="anchor" id="a1fe718e59a733cd6bd6b150a25c578fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void numa_free_cpumask </td>
          <td>(</td>
          <td class="paramtype">struct bitmap *&#160;</td>
          <td class="paramname"><em>cpumask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>frees a previously allocated CPU bitmask </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cpumask</td><td>pointer to a previously allocated CPU bitmask </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a43978141ec7fa1f3a6e88df8d6360ce8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void numa_free_nodemask </td>
          <td>(</td>
          <td class="paramtype">struct bitmap *&#160;</td>
          <td class="paramname"><em>nodemask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>frees a previously allocated node bitmask </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodemask</td><td>pointer to a previously allocated node bitmask </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a16ed82504021427c568854931c11bc3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct bitmap* numa_get_interleave_mask </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the current interleave mask </p>
<dl class="section return"><dt>Returns</dt><dd>bitmask representing the current interleave state</dd></dl>
<p>returns the current interleave mask if the task's memory allocation policy is page interleaved. Otherwise, this function returns an empty mask. </p>

</div>
</div>
<a class="anchor" id="a99fe7a1a08688f1bc6cded282e402a00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct bitmap* numa_get_membind </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the mask of nodes from which memory can currently be allocated. </p>
<dl class="section return"><dt>Returns</dt><dd>bitmap of nodes from which can be allocated </dd></dl>

</div>
</div>
<a class="anchor" id="ae1ddb8059c8b27647d73e0994d2ff6da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct bitmap* numa_get_mems_allowed </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>obtains the nodes the domain is allowed to allocate memory from </p>
<dl class="section return"><dt>Returns</dt><dd>bitmask representing the allowing nodes</dd></dl>
<p>returns the mask of nodes from which the process is allowed to allocate memory in it's current cpuset context. </p>

</div>
</div>
<a class="anchor" id="a599d667326886592bf31dcbac927f62f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct bitmap* numa_get_run_node_mask </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns a mask of CPUs on which the current task is allowed to run. </p>
<dl class="section return"><dt>Returns</dt><dd>bitmap represening the coreids the domain is allowed to run </dd></dl>

</div>
</div>
<a class="anchor" id="a15b30d8531b6205e2499f200d2cfaf8e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">coreid_t numa_max_core </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the highest ID of the present cores </p>
<dl class="section return"><dt>Returns</dt><dd>the maximum coreID in the system</dd>
<dd>
the maximum number of cores in the system </dd></dl>

</div>
</div>
<a class="anchor" id="a6250a0f165beb6f960a48eeec329d65d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nodeid_t numa_max_node </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the highest node number available on the current system. </p>
<dl class="section return"><dt>Returns</dt><dd>ID of the max NUMA node </dd></dl>

</div>
</div>
<a class="anchor" id="aa268e8a2d18fa839340f83da097007f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">errval_t numa_migrate_pages </td>
          <td>(</td>
          <td class="paramtype">domainid_t&#160;</td>
          <td class="paramname"><em>did</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct bitmap *&#160;</td>
          <td class="paramname"><em>fromnodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct bitmap *&#160;</td>
          <td class="paramname"><em>tonodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>migrate a domain from one set of nodes to another </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">did</td><td>the domain ID </td></tr>
    <tr><td class="paramname">fromnodes</td><td>bitmap representing the current nodes </td></tr>
    <tr><td class="paramname">tonodes</td><td>bitmap representing the</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SYS_ERR_OK on SUCCESS </dd></dl>

</div>
</div>
<a class="anchor" id="a8e74f430630f05f1dbc12d45dc4638f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">errval_t numa_move_pages </td>
          <td>(</td>
          <td class="paramtype">domainid_t&#160;</td>
          <td class="paramname"><em>did</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>pages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const nodeid_t *&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">errval_t *&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>moves a list of pages in the address space of the current domain </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">did</td><td>the domain ID </td></tr>
    <tr><td class="paramname">count</td><td>number of pages to move </td></tr>
    <tr><td class="paramname">pages</td><td>list of pages </td></tr>
    <tr><td class="paramname">nodes</td><td>list of nodes to which the pages can be moved </td></tr>
    <tr><td class="paramname">status</td><td>returns the outcome for each page </td></tr>
    <tr><td class="paramname">flags</td><td>flags for moving the pages</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SYS_ERR_OK on SUCCESS </dd></dl>

</div>
</div>
<a class="anchor" id="a310bf8d9e0d7370c2edce74ca4fba972"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">lpaddr_t numa_node_base </td>
          <td>(</td>
          <td class="paramtype">nodeid_t&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>obtains the base address of the numa node </p>
<dl class="section return"><dt>Returns</dt><dd>physical address of the start of the numa node</dd>
<dd>
physical address of the start of the numa node NUMA_NODE_INVALID if the node does not exist </dd></dl>

</div>
</div>
<a class="anchor" id="ab476eca147de64eb11ad7582c660e746"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">coreid_t numa_node_get_core </td>
          <td>(</td>
          <td class="paramtype">nodeid_t&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">coreid_t&#160;</td>
          <td class="paramname"><em>local_core_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>gets the system's core ID for a node/local core id configuration </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad122c91b4830995004e08fc1390cfcdb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nodeid_t numa_node_of_cpu </td>
          <td>(</td>
          <td class="paramtype">coreid_t&#160;</td>
          <td class="paramname"><em>cpu</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the node that a cpu belongs to </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu</td><td>ID of the core</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>node ID on SUCCESS NUMA_NODE_INVALID on FAILURE </dd></dl>

</div>
</div>
<a class="anchor" id="a5643014e5aefb12eba6368afde85e76f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t numa_node_size </td>
          <td>(</td>
          <td class="paramtype">nodeid_t&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t *&#160;</td>
          <td class="paramname"><em>freep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>obtains the size of a node </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>ID of the NUMA node </td></tr>
    <tr><td class="paramname">freep</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size of the node in bytes</dd></dl>
<p>returns the memory size of a node. If the argument freep is not NULL, it used to return the amount of free memory on the node. On error it returns NUMA_NODE_INVALIDalias for NUMA node size 64bit variants</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>ID of the NUMA node </td></tr>
    <tr><td class="paramname">freep</td><td>returns the number of available bytes of the node</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size of the node in bytes</dd></dl>
<p>returns the memory size of a node. If the argument freep is not NULL, it used to return the amount of free memory on the node. On error it returns NUMA_NODE_INVALID </p>

</div>
</div>
<a class="anchor" id="a305bad31ff914f41339eec5243b97044"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">errval_t numa_node_to_cpus </td>
          <td>(</td>
          <td class="paramtype">nodeid_t&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct bitmap *&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>converts a node number to a bitmask of CPUs </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the ID of the node </td></tr>
    <tr><td class="paramname">mask</td><td>bitmap representing the CPUs of this node</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SYS_ERR_OK on SUCCESS NUMA_ERR_BITMAP_RANGE on FAILURE (too small bitmap)</dd></dl>
<p>The user must pass a bitmask structure with a mask buffer long enough to represent all possible cpu's </p>

</div>
</div>
<a class="anchor" id="a4e07ec100973905666625bd87445cbf1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">coreid_t numa_num_configured_cpus </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the total numberof CPUs in the system </p>
<dl class="section return"><dt>Returns</dt><dd>total number of CPUs in the system</dd></dl>
<p>returns the number of cpus in the system. This count includes any cpus that are currently disabled. </p>

</div>
</div>
<a class="anchor" id="a925b757db9361d3dc3035fa80d019e6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nodeid_t numa_num_configured_nodes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtains the number of all memory nodes in the system. </p>
<dl class="section return"><dt>Returns</dt><dd>number of memory nodes in the system</dd></dl>
<p>returns the number of memory nodes in the system. This count includes any nodes that are currently disabled. </p>

</div>
</div>
<a class="anchor" id="a4cc73f3c47d5c97040e9ca1223bd11fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">coreid_t numa_num_node_cpus </td>
          <td>(</td>
          <td class="paramtype">nodeid_t&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>gets the number of cores for the given numa node </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>NUMA node to get the number of cores</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of cores for the node </dd></dl>

</div>
</div>
<a class="anchor" id="a53d194154604d58b25c907745aca1143"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nodeid_t numa_num_possible_nodes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the size of the node mask </p>
<dl class="section return"><dt>Returns</dt><dd>size of the node mask </dd></dl>

</div>
</div>
<a class="anchor" id="a841103c17ae0296b1e26d675dbd2cd38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">coreid_t numa_num_task_cpus </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the number of cpus that the calling domain is allowed to use. </p>
<dl class="section return"><dt>Returns</dt><dd>number of CPUs the domain is allowed to use </dd></dl>

</div>
</div>
<a class="anchor" id="af3c6d92331deff801004a2726312a6de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nodeid_t numa_num_task_nodes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the number of nodes on which the calling domain is allowed to allocate memory </p>
<dl class="section return"><dt>Returns</dt><dd>number of nodes the domain is allowed to use </dd></dl>

</div>
</div>
<a class="anchor" id="a513a087c427fdfdbb8510faa7a8f8af8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t numa_pagesize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the page size </p>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes in a page </dd></dl>

</div>
</div>
<a class="anchor" id="a7f08fdc5f081ab8fd3a340f4cc8351bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">errval_t numa_parse_bitmap </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct bitmap *&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>parses line , which is a character string </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">line</td><td>character string to parse </td></tr>
    <tr><td class="paramname">mask</td><td>bitmap to store the result</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SYS_ERR_OK on SUCCESS NUMA_ERR_BITMAP_PARSE on FAILURE</dd></dl>
<p>The string contains the hexadecimal representation of a bit map.</p>
<p>XXX according to the man pages this function is only used internally </p>

</div>
</div>
<a class="anchor" id="ae71e6b96b51ac951752baf95534a4e88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct bitmap* numa_parse_cpustring </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>parses a character string list of cpus into a bit mask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>character string to parse</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NUMA bitmask on SUCCESS NULL if the string is invalid</dd></dl>
<p>The string is a comma-separated list of cpu numbers or cpu ranges Examples: 1-5,7,10 !4-5 +0-3 </p>

</div>
</div>
<a class="anchor" id="aa9c3be9341e2c8e869617695ec9d3d75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct bitmap* numa_parse_nodestring </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>parses a character string list of nodes into a bit mask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>character string to parse</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NUMA bitmask on SUCCESS NULL if the string is invalid</dd></dl>
<p>The string is a comma-separated list of node numbers or node ranges Examples: 1-5,7,10 !4-5 +0-3</p>
<p>If the string length is zero, then the numa_no_nodes_ptr is returned </p>

</div>
</div>
<a class="anchor" id="a7485ad57e538dad021aaed704f742f8a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nodeid_t numa_preferred </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the preferred node of the current task. </p>
<dl class="section return"><dt>Returns</dt><dd>node ID where memory is preferably allocated </dd></dl>

</div>
</div>
<a class="anchor" id="a1c44a3a92bef81d63508374e66fa133a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* numa_realloc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>old_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>old_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>new_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>changes the size of the memory area. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">old_addr</td><td>pointer ot the old memory region </td></tr>
    <tr><td class="paramname">old_size</td><td>size of the old memory region </td></tr>
    <tr><td class="paramname">new_size</td><td>new size to allocate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab536a7c9a8fd406dce6ec5d5b6a0b5cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">errval_t numa_run_on_node </td>
          <td>(</td>
          <td class="paramtype">nodeid_t&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>runs the current domain on a specific node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>ID of the node to run the domain on</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SYS_ERR_OK on SUCCESS errval on FAILURE</dd></dl>
<p>Passing -1 permits the kernel to schedule on all nodes again </p>

</div>
</div>
<a class="anchor" id="ad0b30a5e75cdc6a864d6801434d332bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">errval_t numa_run_on_node_mask </td>
          <td>(</td>
          <td class="paramtype">struct bitmap *&#160;</td>
          <td class="paramname"><em>nodemask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>runs the current domain only on nodes specified in nodemask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodemask</td><td>bitmap representing the nodes to run the domain on</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SYS_ERR_OK on SUCCESS errval on FAILURE </dd></dl>

</div>
</div>
<a class="anchor" id="a6a534efeb1fdf6965725f260e2a04426"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">errval_t numa_sched_getaffinity </td>
          <td>(</td>
          <td class="paramtype">domainid_t&#160;</td>
          <td class="paramname"><em>did</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct bitmap *&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>retrieves a bitmask of the cpus on which a domain may run </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">did</td><td>domain ID </td></tr>
    <tr><td class="paramname">mask</td><td>returned bitmask</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SYS_ERR_OK on success errval on FAILURE </dd></dl>

</div>
</div>
<a class="anchor" id="afb2dfcff1f36a11ff4d93fb05409d24d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">errval_t numa_sched_setaffinity </td>
          <td>(</td>
          <td class="paramtype">domainid_t&#160;</td>
          <td class="paramname"><em>did</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct bitmap *&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sets a domain's allowed cpu's to those cpu's specified in mask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">did</td><td>domain ID </td></tr>
    <tr><td class="paramname">mask</td><td>bitmap representing the CPUs</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SYS_ERR_OK on success errval on FAILURE </dd></dl>

</div>
</div>
<a class="anchor" id="ad032bb2992091e05ae5c61aca6f902b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void numa_set_bind_policy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="numa_8h.html#a1a08fd9e9d2bc74a52122b6142a09740">numa_policy_t</a>&#160;</td>
          <td class="paramname"><em>strict</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>specify the memory bind policy </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strict</td><td>numa policy to apply</td></tr>
  </table>
  </dd>
</dl>
<p>specifies whether calls that bind memory to a specific node should use the preferred policy or a strict policy. </p>

</div>
</div>
<a class="anchor" id="a4d9646ec73af0a36cdd00302da6aeb0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void numa_set_interleave_mask </td>
          <td>(</td>
          <td class="paramtype">struct bitmap *&#160;</td>
          <td class="paramname"><em>nodemask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sets the memory interleave mask for the current task to nodemask </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodemask</td><td>bitmask representing the nodes</td></tr>
  </table>
  </dd>
</dl>
<p>All new memory allocations are page interleaved over all nodes in the interleave mask. Interleaving can be turned off again by passing an empty mask.</p>
<p>This bitmask is considered to be a hint. Fallback to other nodes may be possible </p>

</div>
</div>
<a class="anchor" id="a03781879a5c16360c1635004f5b3d0ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">errval_t numa_set_membind </td>
          <td>(</td>
          <td class="paramtype">struct bitmap *&#160;</td>
          <td class="paramname"><em>nodemask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sets the memory allocation mask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodemask</td><td>bitmap representing the nodes</td></tr>
  </table>
  </dd>
</dl>
<p>The task will only allocate memory from the nodes set in nodemask.</p>
<p>an empty mask or not allowed nodes in the mask will result in an error </p>

</div>
</div>
<a class="anchor" id="a3bfe6513e958b53670773c66e803942c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void numa_set_preferred </td>
          <td>(</td>
          <td class="paramtype">nodeid_t&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sets the preferred node for the current task to node </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>ID of the node to set preferred</td></tr>
  </table>
  </dd>
</dl>
<p>The system will attempt to allocate memory from the preferred node, but will fall back to other nodes if no memory is available on the the preferred node</p>
<p>Passing a node of -1 argument specifies local allocation </p>

</div>
</div>
<a class="anchor" id="a8ac29d7b257c787bc1768f6ef6151487"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void numa_set_strict </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="numa_8h.html#a1a08fd9e9d2bc74a52122b6142a09740">numa_policy_t</a>&#160;</td>
          <td class="paramname"><em>strict</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>enable or disable the strict allocation policy </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strict</td><td>numa policy to apply</td></tr>
  </table>
  </dd>
</dl>
<p>s a flag that says whether the functions allocating on specific nodes should use a strict policy. Strict means the allocation will fail if the memory cannot be allocated on the target node. </p>

</div>
</div>
<a class="anchor" id="afa4c95e6de6697f9260b075825a151d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void numa_warn </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>is a libnuma internal function that can be also overridden by the user program. It is called to warn the user when a libnuma function encounters a non-fatal error. The default implementation prints a warning to stderr. The first argument is a unique number identifying each warning. After that there is a printf(3)-style format string and a variable number of arguments. numa_warn exits the program when numa_exit_on_warn is set to a non-zero value. The default value of numa_exit_on_warn is zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">number</td><td></td></tr>
    <tr><td class="paramname">where</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
